\section{Background and Motivating Example}
\label{sec:motivating-example}

A type is a set of run-time values.
% A static type overestimate possible run-time values. 
A \textit{type qualifier}~\cite{FosterFFA99}
is a restriction on a type that limits which run-time values
the qualified type can represent. For example, \<positive int>
is a qualified type: \<positive> is the type qualifier, and \<int>
is the base type.
%
A pluggable type system consists of a hierarchy of type qualifiers.

Practical pluggable type systems are flow-sensitive.
For example, after an assignment \codeid{x.f = somePositive} or a test
\codeid{x.f > 0}, the type of \<x.f>
might change from \<int> to \<positive int>
until a possible side effect or a control flow join.
%
Each pluggable typechecker is therefore effectively
an abstract interpretation~\cite{Cousot1997}, with the
abstract interpretation's lattice being equivalent to
the type qualifier hierarchy.

Like the host type systems to which they are applied,
pluggable type systems are modular:  they can be run incrementally on a
procedure or a file at a time, rather than requiring a whole-program
analysis.

For example, consider a pluggable type system
designed to prevent negative array accesses.
It would require that the type of any array access is non-negative.
The following code does not type-check as written:

\begin{Verbatim}
// Returns the value in a at the index. For this procedure,
// the first element of the array is at index 1.
string getOneIndexed(string[] a, int index) {
  return a[i - 1];
}
\end{Verbatim}

Because \<index>'s type \<int> is an unqualified type from the host language
(\ie a ``base type''),
a pluggable typechecker would \emph{default}
it, most likely to a worst-case assumption that \<index> could
be any integer (the ``top qualifier'' or $\top$).
%
With this type, every call to \<getOneIndexed> would typecheck, but its
body would not.


To make the code typecheck (equivalently, to verify that its array accesses
are not at negative indices)
a programmer would write the formal parameter as
\<positive int index>.

Within the procedure body, the typechecker \emph{relies} on the fact that
\<index> has type <positive int>.  At call sites, the typechecker
\emph{guarantees} that only postive integers are passed as arguments.  So
long as every procedure is checked, this approach is sound.

The typechecker is modular:  it can visit each procedure
once\footnote{While type-checking is modular, type inference is a
super-linear whole-program analysis.}
and never has to reason across procedure
boundaries, but only to use the specification (the types) of called procedures.

The annotation burden scales linearly with the size of the code
base, which may be large for legacy code.  Furthermore,
many pluggable type systems require significant numbers of annotations.
For example, a pluggable type system for preventing out-of-bounds array accesses
required
one type qualifier for every 32 lines of non-comment, non-blank code~\cite{KelloggDME2018}.

Our goal in this work is to avoid the burden of writing these type qualifiers
by automatically taking a flow-sensitive, modular pluggable typechecker
like the ones that exist in practice and transforming it into one that performs
inter-procedural inference.

\todo{Discuss the difference between type inference and type
  reconstruction?  Probably just give a nod to type reconstruction in the
  related work.  Our experiments are type reconstruction.}
