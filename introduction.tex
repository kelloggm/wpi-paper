\section{Introduction}
\label{sec:intro}

\todo{Turn this into actual text with references rather than bullets.}

Pluggable type systems~\cite{FosterFFA99} augment a host type system
with \emph{type qualifiers} that track information about a property of
interest. Researchers have devised practical pluggable type systems
to prevent numerous kinds of defects, including null-pointer
dereferences~\cite{BanerjeeCS2019,PapiACPE2008,DietlDEMS2011},
array-bounds violations~\cite{KelloggDME2018},
violations of locking discipline~\cite{ErnstLMST2016},
mutations of immutable data~\cite{DietlDEMS2011,PapiACPE2008,coblenz2017glacier},
and others. Industrial deployments of pluggable type systems
have been reported by Amazon~\cite{KelloggSTE2020,KelloggRSSE2020},
Uber~\cite{BanerjeeCS2019}, and \todo{references for others in Mike's
  usual list, e.g., Google}.

An advantage of deploying a pluggable type system is that programmers
are familiar with type systems and are used to writing types, because
they are programming in a host language like Java or C\# with static
types.
Once applied, the type qualifiers provide benefits: the typechecker can check
their correctness, and they serve as concise documentation.
However, the process of applying a pluggable type system to a legacy codebase
(\ie writing type qualifiers)
is time-consuming and intimidating for developers.

This problem also applies to non-pluggable type systems: some developers
prefer untyped or dynamically-typed languages like Python or JavaScript
because they do not want to write type annotations.
%
The traditional approach to solving this problem is \emph{type inference}:
deducing the proper types for a program from the program's structure
by solving a set of constraints induced by type uses.
%
Type inference systems for languages with Hindley-Milner type systems
are well-developed~\cite{DamasM1982} (\todo{add more recent citations, maybe
  say something about more complex dependent type systems?}).
%
Type inference for popular dynamic languages like Python is an open
research problem. Researchers have proposed approaches based
on MaxSAT~\cite{hassan2018maxsmt} and machine learning~\cite{xu2016python,peng2022static}.

Unfortunately, none of these approaches are practical for pluggable types.
Building a type inference algorithm in the style of Algorithm W for each
type system is impractical: there are too many pluggable type systems.
A similar problem occurs when trying to build a constraint system to
dispatch to an SMT solver: the type rules of the specific pluggable type system
need to be encoded in the constraint-generation rules. Finally, approaches
based on machine learning, while promising, lack sufficient training data for
many pluggable type systems.
%
We desire an
inference algorithm that is \emph{generic} over the pluggable type system
to which it is applied: the type system designer should not need to
make modifications to their type system implmentation in order to access
the benefits of type inference.

To that end, we propose a general type inference algorithm for pluggable type
systems that is applicable to any \emph{flow-sensitive} pluggable type system.
Our key insight is that
practical frameworks for building pluggable type systems already provide
\emph{local} type inference in the form of flow-sensitivity within the body
of methods.
We modify the underlying qualified type rules provided by the pluggable type
system framework to record inferred summaries.
Our approach then iteratively applies these modified rules until the summaries
reach fixpoint to generate a candidate set of type qualifiers.
We can then provide this candidate set of qualifiers to the original
pluggable typechecker: assuming that the typechecker is sound, if the program
typechecks with a candidate set of qualifiers, those qualifiers are trivially
known to be correct.

We implemented this idea for the Checker Framework~\cite{PapiACPE2008},
a popular open-source pluggable type system
framework for Java.
%
\todo{There were some difficulties along the way---we're going to
impress you with our clever solution to tricky problems, and also how much
engineering we did.}
%
We used our tools to run \todo{X} different pluggable typecheckers
on \todo{some massive number of} lines of code to demonstrate that
our approach is both effective and general.
We found that our inference approach infers \todo{Y\%} of human-written
type qualifiers.

\todo{Decide if we're actually going to do this.}
We also compared our approach to bespoke inference systems that build
systems of constraints for particular type systems, like nullness or
maybe CFI (if Werner is an author of this paper). We show that our approach
produces similarly-good results, but didn't require a ton of extra
implementation effort for each new type system.

Our contributions are:
\begin{itemize}
\item a novel type inference algorithm for flow-sensitive pluggable
  typecheckers (\cref{sec:core-algorithm});
\item a collection of enhancements to the algorithm that are necessary to
  make it practical (\cref{sec:difficulties});
\item an implementation of our new type inference algorithm for a framework
  for building pluggable typecheckers (\cref{sec:implementation});
\item an evaluation of our implementation, that shows that it can infer
  \todo{X}\% of human-written annotations in \todo{Y} projects totalling
  \todo{Z} lines of non-comment, non-blank Java code, across \todo{W} different
  pluggable typecheckers (\cref{sec:evaluation}); and,
\item a comparison of our generic algorithm to specialized inference
  techniques for specific typecheckers, which demonstrates that our generic
  approach is about as good at inferring annotations but requires less
  custom code (\cref{sec:comparison}).
\end{itemize}
