/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.zookeeper.server.quorum;

import static org.apache.zookeeper.common.NetUtils.formatInetAddr;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.StringReader;
import java.io.StringWriter;
import java.io.Writer;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import javax.security.sasl.SaslException;
import org.apache.yetus.audience.InterfaceAudience;
import org.apache.zookeeper.KeeperException.BadArgumentsException;
import org.apache.zookeeper.common.AtomicFileWritingIdiom;
import org.apache.zookeeper.common.AtomicFileWritingIdiom.WriterStatement;
import org.apache.zookeeper.common.QuorumX509Util;
import org.apache.zookeeper.common.X509Exception;
import org.apache.zookeeper.jmx.MBeanRegistry;
import org.apache.zookeeper.jmx.ZKMBeanInfo;
import org.apache.zookeeper.server.ServerCnxn;
import org.apache.zookeeper.server.ServerCnxnFactory;
import org.apache.zookeeper.server.ServerMetrics;
import org.apache.zookeeper.server.ZKDatabase;
import org.apache.zookeeper.server.ZooKeeperServer;
import org.apache.zookeeper.server.ZooKeeperThread;
import org.apache.zookeeper.server.admin.AdminServer;
import org.apache.zookeeper.server.admin.AdminServer.AdminServerException;
import org.apache.zookeeper.server.admin.AdminServerFactory;
import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
import org.apache.zookeeper.server.quorum.QuorumPeerConfig.ConfigException;
import org.apache.zookeeper.server.quorum.auth.NullQuorumAuthLearner;
import org.apache.zookeeper.server.quorum.auth.NullQuorumAuthServer;
import org.apache.zookeeper.server.quorum.auth.QuorumAuth;
import org.apache.zookeeper.server.quorum.auth.QuorumAuthLearner;
import org.apache.zookeeper.server.quorum.auth.QuorumAuthServer;
import org.apache.zookeeper.server.quorum.auth.SaslQuorumAuthLearner;
import org.apache.zookeeper.server.quorum.auth.SaslQuorumAuthServer;
import org.apache.zookeeper.server.quorum.flexible.QuorumMaj;
import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;
import org.apache.zookeeper.server.util.ConfigUtils;
import org.apache.zookeeper.server.util.JvmPauseMonitor;
import org.apache.zookeeper.server.util.ZxidUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.checkerframework.checker.calledmethods.qual.*;
import org.checkerframework.checker.mustcall.qual.*;

/**
 * This class manages the quorum protocol. There are three states this server
 * can be in:
 * <ol>
 * <li>Leader election - each server will elect a leader (proposing itself as a
 * leader initially).</li>
 * <li>Follower - the server will synchronize with the leader and replicate any
 * transactions.</li>
 * <li>Leader - the server will process requests and forward them to followers.
 * A majority of followers must log the request before it can be accepted.
 * </ol>
 *
 * This class will setup a datagram socket that will always respond with its
 * view of the current leader. The response will take the form of:
 *
 * <pre>
 * int xid;
 *
 * long myid;
 *
 * long leader_id;
 *
 * long leader_zxid;
 * </pre>
 *
 * The request for the current leader will consist solely of an xid: int xid;
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.resourceleak.ResourceLeakChecker")
@org.checkerframework.checker.mustcall.qual.InheritableMustCall({ "shutdown" })
public class QuorumPeer extends ZooKeeperThread implements QuorumStats.Provider {

    private static final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Logger LOG = LoggerFactory.getLogger(QuorumPeer.class);

    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumBean jmxQuorumBean;

    @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) LocalPeerBean jmxLocalPeerBean;

    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Map<Long, RemotePeerBean> jmxRemotePeerBean;

    @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) LeaderElectionBean jmxLeaderElectionBean;

    // The QuorumCnxManager is held through an AtomicReference to ensure cross-thread visibility
    // of updates; see the implementation comment at setLastSeenQuorumVerifier().
    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) AtomicReference<QuorumCnxManager> qcmRef = new AtomicReference<>();

    @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumAuthServer authServer;

    @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumAuthLearner authLearner;

    /**
     * ZKDatabase is a top level member of quorumpeer
     * which will be used in all the zookeeperservers
     * instantiated later. Also, it is created once on
     * bootup and only thrown away in case of a truncate
     * message from the leader
     */
    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ZKDatabase zkDb;

    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) JvmPauseMonitor jvmPauseMonitor;

    public static final class AddressTuple {

        public final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) MultipleAddresses quorumAddr;

        public final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) MultipleAddresses electionAddr;

        public final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) InetSocketAddress clientAddr;

        public AddressTuple(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) MultipleAddresses quorumAddr, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) MultipleAddresses electionAddr, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) InetSocketAddress clientAddr) {
            this.quorumAddr = quorumAddr;
            this.electionAddr = electionAddr;
            this.clientAddr = clientAddr;
        }
    }

    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int observerMasterPort;

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int getObserverMasterPort(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return observerMasterPort;
    }

    public void setObserverMasterPort(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "setConnectToLearnerMasterLimit" }) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int observerMasterPort) {
        this.observerMasterPort = observerMasterPort;
    }

    public static final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String CONFIG_KEY_MULTI_ADDRESS_ENABLED = "zookeeper.multiAddress.enabled";

    public static final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String CONFIG_DEFAULT_MULTI_ADDRESS_ENABLED = "false";

    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean multiAddressEnabled = true;

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isMultiAddressEnabled(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return multiAddressEnabled;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "org.apache.zookeeper.server.quorum.QuorumPeer.LOG" }, methods = { "info" })
    public void setMultiAddressEnabled(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean multiAddressEnabled) {
        this.multiAddressEnabled = multiAddressEnabled;
        LOG.info("multiAddress.enabled set to {}", multiAddressEnabled);
    }

    public static final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String CONFIG_KEY_MULTI_ADDRESS_REACHABILITY_CHECK_TIMEOUT_MS = "zookeeper.multiAddress.reachabilityCheckTimeoutMs";

    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int multiAddressReachabilityCheckTimeoutMs = (int) MultipleAddresses.DEFAULT_TIMEOUT.toMillis();

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int getMultiAddressReachabilityCheckTimeoutMs(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return multiAddressReachabilityCheckTimeoutMs;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "org.apache.zookeeper.server.quorum.QuorumPeer.LOG" }, methods = { "info" })
    public void setMultiAddressReachabilityCheckTimeoutMs(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "setMultiAddressReachabilityCheckEnabled" }) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int multiAddressReachabilityCheckTimeoutMs) {
        this.multiAddressReachabilityCheckTimeoutMs = multiAddressReachabilityCheckTimeoutMs;
        LOG.info("multiAddress.reachabilityCheckTimeoutMs set to {}", multiAddressReachabilityCheckTimeoutMs);
    }

    public static final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String CONFIG_KEY_MULTI_ADDRESS_REACHABILITY_CHECK_ENABLED = "zookeeper.multiAddress.reachabilityCheckEnabled";

    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean multiAddressReachabilityCheckEnabled = true;

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isMultiAddressReachabilityCheckEnabled(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return multiAddressReachabilityCheckEnabled;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "org.apache.zookeeper.server.quorum.QuorumPeer.LOG" }, methods = { "info" })
    public void setMultiAddressReachabilityCheckEnabled(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "setMultiAddressEnabled" }) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean multiAddressReachabilityCheckEnabled) {
        this.multiAddressReachabilityCheckEnabled = multiAddressReachabilityCheckEnabled;
        LOG.info("multiAddress.reachabilityCheckEnabled set to {}", multiAddressReachabilityCheckEnabled);
    }

    public static class QuorumServer {

        public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) MultipleAddresses addr = new MultipleAddresses();

        public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) MultipleAddresses electionAddr = new MultipleAddresses();

        public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) InetSocketAddress clientAddr = null;

        public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long id;

        public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String hostname;

        public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) LearnerType type = LearnerType.PARTICIPANT;

        public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isClientAddrFromStatic = false;

        private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) List<InetSocketAddress> myAddrs;

        public QuorumServer(long id, InetSocketAddress addr, InetSocketAddress electionAddr, InetSocketAddress clientAddr) {
            this(id, addr, electionAddr, clientAddr, LearnerType.PARTICIPANT);
        }

        public QuorumServer(long id, InetSocketAddress addr, InetSocketAddress electionAddr) {
            this(id, addr, electionAddr, null, LearnerType.PARTICIPANT);
        }

        // VisibleForTesting
        public QuorumServer( @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long id, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) InetSocketAddress addr) {
            this(id, addr, null, null, LearnerType.PARTICIPANT);
        }

        @org.checkerframework.dataflow.qual.Pure
        public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long getId(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumServer this) {
            return id;
        }

        /**
         * Performs a DNS lookup for server address and election address.
         *
         * If the DNS lookup fails, this.addr and electionAddr remain
         * unmodified.
         */
        public void recreateSocketAddresses(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumServer this) {
            if (this.addr.isEmpty()) {
                LOG.warn("Server address has not been initialized");
                return;
            }
            if (this.electionAddr.isEmpty()) {
                LOG.warn("Election address has not been initialized");
                return;
            }
            this.addr.recreateSocketAddresses();
            this.electionAddr.recreateSocketAddresses();
        }

        @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#1" }, methods = { "trim" })
        private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) LearnerType getType(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumServer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String s) throws ConfigException {
            switch(s.trim().toLowerCase()) {
                case "observer":
                    return LearnerType.OBSERVER;
                case "participant":
                    return LearnerType.PARTICIPANT;
                default:
                    throw new ConfigException("Unrecognised peertype: " + s);
            }
        }

        private static final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String wrongFormat = " does not have the form server_config or server_config;client_config where server_config is the pipe separated list of host:port:port or host:port:port:type and client_config is port or host:port";

        @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#2" }, methods = { "split" })
        public QuorumServer( @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long sid, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String addressStr) throws ConfigException {
            this.id = sid;
            LearnerType newType = null;
            String[] serverClientParts = addressStr.split(";");
            String[] serverAddresses = serverClientParts[0].split("\\|");
            if (serverClientParts.length == 2) {
                String[] clientParts = ConfigUtils.getHostAndPort(serverClientParts[1]);
                if (clientParts.length > 2) {
                    throw new ConfigException(addressStr + wrongFormat);
                }
                // is client_config a host:port or just a port
                hostname = (clientParts.length == 2) ? clientParts[0] : "0.0.0.0";
                try {
                    clientAddr = new InetSocketAddress(hostname, Integer.parseInt(clientParts[clientParts.length - 1]));
                } catch (NumberFormatException e) {
                    throw new ConfigException("Address unresolved: " + hostname + ":" + clientParts[clientParts.length - 1]);
                }
            }
            boolean multiAddressEnabled = Boolean.parseBoolean(System.getProperty(QuorumPeer.CONFIG_KEY_MULTI_ADDRESS_ENABLED, QuorumPeer.CONFIG_DEFAULT_MULTI_ADDRESS_ENABLED));
            if (!multiAddressEnabled && serverAddresses.length > 1) {
                throw new ConfigException("Multiple address feature is disabled, but multiple addresses were specified for sid " + sid);
            }
            for (String serverAddress : serverAddresses) {
                String[] serverParts = ConfigUtils.getHostAndPort(serverAddress);
                if ((serverClientParts.length > 2) || (serverParts.length < 3) || (serverParts.length > 4)) {
                    throw new ConfigException(addressStr + wrongFormat);
                }
                // server_config should be either host:port:port or host:port:port:type
                InetSocketAddress tempAddress;
                InetSocketAddress tempElectionAddress;
                try {
                    tempAddress = new InetSocketAddress(serverParts[0], Integer.parseInt(serverParts[1]));
                    addr.addAddress(tempAddress);
                } catch (NumberFormatException e) {
                    throw new ConfigException("Address unresolved: " + serverParts[0] + ":" + serverParts[1]);
                }
                try {
                    tempElectionAddress = new InetSocketAddress(serverParts[0], Integer.parseInt(serverParts[2]));
                    electionAddr.addAddress(tempElectionAddress);
                } catch (NumberFormatException e) {
                    throw new ConfigException("Address unresolved: " + serverParts[0] + ":" + serverParts[2]);
                }
                if (tempAddress.getPort() == tempElectionAddress.getPort()) {
                    throw new ConfigException("Client and election port must be different! Please update the configuration file on server." + sid);
                }
                if (serverParts.length == 4) {
                    LearnerType tempType = getType(serverParts[3]);
                    if (newType == null) {
                        newType = tempType;
                    }
                    if (newType != tempType) {
                        throw new ConfigException("Multiple addresses should have similar roles: " + type + " vs " + tempType);
                    }
                }
                this.hostname = serverParts[0];
            }
            if (newType != null) {
                type = newType;
            }
            setMyAddrs();
        }

        public QuorumServer(long id, InetSocketAddress addr, InetSocketAddress electionAddr, LearnerType type) {
            this(id, addr, electionAddr, null, type);
        }

        @org.checkerframework.framework.qual.RequiresQualifier(expression = { "this.clientAddr" }, qualifier = org.checkerframework.checker.calledmethods.qual.CalledMethodsBottom.class)
        public QuorumServer( @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long id, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) InetSocketAddress addr, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) InetSocketAddress electionAddr, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) InetSocketAddress clientAddr, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) LearnerType type) {
            this.id = id;
            if (addr != null) {
                this.addr.addAddress(addr);
            }
            if (electionAddr != null) {
                this.electionAddr.addAddress(electionAddr);
            }
            this.type = type;
            this.clientAddr = clientAddr;
            setMyAddrs();
        }

        @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "excludedSpecialAddresses" })
        private void setMyAddrs(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumServer this) {
            this.myAddrs = new ArrayList<>();
            this.myAddrs.addAll(this.addr.getAllAddresses());
            this.myAddrs.add(this.clientAddr);
            this.myAddrs.addAll(this.electionAddr.getAllAddresses());
            this.myAddrs = excludedSpecialAddresses(this.myAddrs);
        }

        @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#1" }, methods = { "getHostString" })
        public static @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String delimitedHostString(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) InetSocketAddress addr) {
            String host = addr.getHostString();
            if (host.contains(":")) {
                return "[" + host + "]";
            } else {
                return host;
            }
        }

        public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String toString(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumServer this) {
            StringWriter sw = new StringWriter();
            List<InetSocketAddress> addrList = new LinkedList<>(addr.getAllAddresses());
            List<InetSocketAddress> electionAddrList = new LinkedList<>(electionAddr.getAllAddresses());
            if (addrList.size() > 0 && electionAddrList.size() > 0) {
                addrList.sort(Comparator.comparing(InetSocketAddress::getHostString));
                electionAddrList.sort(Comparator.comparing(InetSocketAddress::getHostString));
                sw.append(IntStream.range(0, addrList.size()).mapToObj(i -> String.format("%s:%d:%d", delimitedHostString(addrList.get(i)), addrList.get(i).getPort(), electionAddrList.get(i).getPort())).collect(Collectors.joining("|")));
            }
            if (type == LearnerType.OBSERVER) {
                sw.append(":observer");
            } else if (type == LearnerType.PARTICIPANT) {
                sw.append(":participant");
            }
            if (clientAddr != null && !isClientAddrFromStatic) {
                sw.append(";");
                sw.append(delimitedHostString(clientAddr));
                sw.append(":");
                sw.append(String.valueOf(clientAddr.getPort()));
            }
            return sw.toString();
        }

        @org.checkerframework.dataflow.qual.Pure
        public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int hashCode(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumServer this) {
            assert false : "hashCode not designed";
            // any arbitrary constant will do
            return 42;
        }

        @org.checkerframework.dataflow.qual.Pure
        private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean checkAddressesEqual(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumServer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) InetSocketAddress addr1, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) InetSocketAddress addr2) {
            return (addr1 != null || addr2 == null) && (addr1 == null || addr2 != null) && (addr1 == null || addr2 == null || addr1.equals(addr2));
        }

        @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "checkAddressesEqual" })
        public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean equals(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumServer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Object o) {
            if (!(o instanceof QuorumServer)) {
                return false;
            }
            QuorumServer qs = (QuorumServer) o;
            if ((qs.id != id) || (qs.type != type)) {
                return false;
            }
            if (!addr.equals(qs.addr)) {
                return false;
            }
            if (!electionAddr.equals(qs.electionAddr)) {
                return false;
            }
            return checkAddressesEqual(clientAddr, qs.clientAddr);
        }

        @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "excludedSpecialAddresses" })
        public void checkAddressDuplicate(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumServer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumServer s) throws BadArgumentsException {
            List<InetSocketAddress> otherAddrs = new ArrayList<>(s.addr.getAllAddresses());
            otherAddrs.add(s.clientAddr);
            otherAddrs.addAll(s.electionAddr.getAllAddresses());
            otherAddrs = excludedSpecialAddresses(otherAddrs);
            for (InetSocketAddress my : this.myAddrs) {
                for (InetSocketAddress other : otherAddrs) {
                    if (my.equals(other)) {
                        String error = String.format("%s of server.%d conflicts %s of server.%d", my, this.id, other, s.id);
                        throw new BadArgumentsException(error);
                    }
                }
            }
        }

        @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#1" }, methods = { "iterator" })
        private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) List<InetSocketAddress> excludedSpecialAddresses(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumServer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({ "addAll" }) List<InetSocketAddress> addrs) {
            List<InetSocketAddress> included = new ArrayList<>();
            for (InetSocketAddress addr : addrs) {
                if (addr == null) {
                    continue;
                }
                InetAddress inetaddr = addr.getAddress();
                if (// wildCard addresses (0.0.0.0 or [::])
                inetaddr == null || inetaddr.isAnyLocalAddress() || inetaddr.isLoopbackAddress()) {
                    // loopback address(localhost/127.0.0.1)
                    continue;
                }
                included.add(addr);
            }
            return included;
        }
    }

    public enum ServerState {

        LOOKING, FOLLOWING, LEADING, OBSERVING
    }

    /**
     * (Used for monitoring) shows the current phase of
     * Zab protocol that peer is running.
     */
    public enum ZabState {

        ELECTION, DISCOVERY, SYNCHRONIZATION, BROADCAST
    }

    /**
     * (Used for monitoring) When peer is in synchronization phase, this shows
     * which synchronization mechanism is being used
     */
    public enum SyncMode {

        NONE, DIFF, SNAP, TRUNC
    }

    /*
     * A peer can either be participating, which implies that it is willing to
     * both vote in instances of consensus and to elect or become a Leader, or
     * it may be observing in which case it isn't.
     *
     * We need this distinction to decide which ServerState to move to when
     * conditions change (e.g. which state to become after LOOKING).
     */
    public enum LearnerType {

        PARTICIPANT, OBSERVER
    }

    /*
     * To enable observers to have no identifier, we need a generic identifier
     * at least for QuorumCnxManager. We use the following constant to as the
     * value of such a generic identifier.
     */
    static final  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long OBSERVER_ID = Long.MAX_VALUE;

    /*
     * Record leader election time
     */
    // fle = fast leader election
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long start_fle, end_fle;

    public static final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String FLE_TIME_UNIT = "MS";

    /*
     * Default value of peer is participant
     */
    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) LearnerType learnerType = LearnerType.PARTICIPANT;

    @org.checkerframework.dataflow.qual.Pure
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) LearnerType getLearnerType(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return learnerType;
    }

    /**
     * Sets the LearnerType
     */
    public void setLearnerType(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) LearnerType p) {
        learnerType = p;
    }

    protected synchronized void setConfigFileName(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "setObserverMasterPort" }) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String s) {
        configFilename = s;
    }

    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String configFilename = null;

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getVotingView" })
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int getQuorumSize(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return getVotingView().size();
    }

    public void setJvmPauseMonitor(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "initialize" }) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) JvmPauseMonitor jvmPauseMonitor) {
        this.jvmPauseMonitor = jvmPauseMonitor;
    }

    /**
     * QuorumVerifier implementation; default (majority).
     */
    //last committed quorum verifier
    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumVerifier quorumVerifier;

    //last proposed quorum verifier
    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumVerifier lastSeenQuorumVerifier = null;

    // Lock object that guard access to quorumVerifier and lastSeenQuorumVerifier.
    final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Object QV_LOCK = new Object();

    /**
     * My id
     */
    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long myid;

    /**
     * get the id of this quorum peer.
     */
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long getId(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return myid;
    }

    // VisibleForTesting
    void setId(long id) {
        this.myid = id;
    }

    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean sslQuorum;

    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean shouldUsePortUnification;

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isSslQuorum(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return sslQuorum;
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean shouldUsePortUnification(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return shouldUsePortUnification;
    }

    private final @org.checkerframework.checker.mustcall.qual.Owning @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumX509Util x509Util;

    @org.checkerframework.dataflow.qual.Pure
    @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumX509Util getX509Util(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return x509Util;
    }

    /**
     * This is who I think the leader currently is.
     */
    private volatile @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Vote currentVote;

    @org.checkerframework.dataflow.qual.Pure
    public synchronized @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Vote getCurrentVote(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return currentVote;
    }

    public synchronized void setCurrentVote(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Vote v) {
        currentVote = v;
    }

    private volatile  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean running = true;

    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String initialConfig;

    /**
     * The number of milliseconds of each tick
     */
    protected  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int tickTime;

    /**
     * Whether learners in this quorum should create new sessions as local.
     * False by default to preserve existing behavior.
     */
    protected  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean localSessionsEnabled = false;

    /**
     * Whether learners in this quorum should upgrade local sessions to
     * global. Only matters if local sessions are enabled.
     */
    protected  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean localSessionsUpgradingEnabled = true;

    /**
     * Minimum number of milliseconds to allow for session timeout.
     * A value of -1 indicates unset, use default.
     */
    protected  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int minSessionTimeout = -1;

    /**
     * Maximum number of milliseconds to allow for session timeout.
     * A value of -1 indicates unset, use default.
     */
    protected  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int maxSessionTimeout = -1;

    /**
     * The ZooKeeper server's socket backlog length. The number of connections
     * that will be queued to be read before new connections are dropped. A
     * value of one indicates the default backlog will be used.
     */
    protected  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int clientPortListenBacklog = -1;

    /**
     * The number of ticks that the initial synchronization phase can take
     */
    protected volatile  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int initLimit;

    /**
     * The number of ticks that can pass between sending a request and getting
     * an acknowledgment
     */
    protected volatile  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int syncLimit;

    /**
     * The number of ticks that can pass before retrying to connect to learner master
     */
    protected volatile  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int connectToLearnerMasterLimit;

    /**
     * Enables/Disables sync request processor. This option is enabled
     * by default and is to be used with observers.
     */
    protected  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean syncEnabled = true;

    /**
     * The current tick
     */
    protected @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) AtomicInteger tick = new AtomicInteger();

    /**
     * Whether or not to listen on all IPs for the two quorum ports
     * (broadcast and fast leader election).
     */
    protected  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean quorumListenOnAllIPs = false;

    /**
     * Keeps time taken for leader election in milliseconds. Sets the value to
     * this variable only after the completion of leader election.
     */
    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long electionTimeTaken = -1;

    /**
     * Enable/Disables quorum authentication using sasl. Defaulting to false.
     */
    protected  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean quorumSaslEnableAuth;

    /**
     * If this is false, quorum peer server will accept another quorum peer client
     * connection even if the authentication did not succeed. This can be used while
     * upgrading ZooKeeper server. Defaulting to false (required).
     */
    protected  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean quorumServerSaslAuthRequired;

    /**
     * If this is false, quorum peer learner will talk to quorum peer server
     * without authentication. This can be used while upgrading ZooKeeper
     * server. Defaulting to false (required).
     */
    protected  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean quorumLearnerSaslAuthRequired;

    /**
     * Kerberos quorum service principal. Defaulting to 'zkquorum/localhost'.
     */
    protected @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String quorumServicePrincipal;

    /**
     * Quorum learner login context name in jaas-conf file to read the kerberos
     * security details. Defaulting to 'QuorumLearner'.
     */
    protected @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String quorumLearnerLoginContext;

    /**
     * Quorum server login context name in jaas-conf file to read the kerberos
     * security details. Defaulting to 'QuorumServer'.
     */
    protected @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String quorumServerLoginContext;

    // TODO: need to tune the default value of thread size
    private static final  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int QUORUM_CNXN_THREADS_SIZE_DEFAULT_VALUE = 20;

    /**
     * The maximum number of threads to allow in the connectionExecutors thread
     * pool which will be used to initiate quorum server connections.
     */
    protected  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int quorumCnxnThreadsSize = QUORUM_CNXN_THREADS_SIZE_DEFAULT_VALUE;

    public static final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String QUORUM_CNXN_TIMEOUT_MS = "zookeeper.quorumCnxnTimeoutMs";

    private static  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int quorumCnxnTimeoutMs;

    static {
        quorumCnxnTimeoutMs = Integer.getInteger(QUORUM_CNXN_TIMEOUT_MS, -1);
        LOG.info("{}={}", QUORUM_CNXN_TIMEOUT_MS, quorumCnxnTimeoutMs);
    }

    /**
     * @deprecated As of release 3.4.0, this class has been deprecated, since
     * it is used with one of the udp-based versions of leader election, which
     * we are also deprecating.
     *
     * This class simply responds to requests for the current leader of this
     * node.
     * <p>
     * The request contains just an xid generated by the requestor.
     * <p>
     * The response has the xid, the id of this server, the id of the leader,
     * and the zxid of the leader.
     */
    class ResponderThread extends ZooKeeperThread {

        @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "<init>" })
        ResponderThread() {
            super("ResponderThread");
        }

        volatile  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean running = true;

        @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getCurrentVote", "getPeerState" })
        public void run(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ResponderThread this) {
            try {
                byte[] b = new byte[36];
                ByteBuffer responseBuffer = ByteBuffer.wrap(b);
                DatagramPacket packet = new DatagramPacket(b, b.length);
                while (running) {
                    udpSocket.receive(packet);
                    if (packet.getLength() != 4) {
                        LOG.warn("Got more than just an xid! Len = {}", packet.getLength());
                    } else {
                        responseBuffer.clear();
                        // Skip the xid
                        responseBuffer.getInt();
                        responseBuffer.putLong(myid);
                        Vote current = getCurrentVote();
                        switch(getPeerState()) {
                            case LOOKING:
                                responseBuffer.putLong(current.getId());
                                responseBuffer.putLong(current.getZxid());
                                break;
                            case LEADING:
                                responseBuffer.putLong(myid);
                                try {
                                    long proposed;
                                    synchronized (leader) {
                                        proposed = leader.lastProposed;
                                    }
                                    responseBuffer.putLong(proposed);
                                } catch (NullPointerException npe) {
                                    // This can happen in state transitions,
                                    // just ignore the request
                                }
                                break;
                            case FOLLOWING:
                                responseBuffer.putLong(current.getId());
                                try {
                                    responseBuffer.putLong(follower.getZxid());
                                } catch (NullPointerException npe) {
                                    // This can happen in state transitions,
                                    // just ignore the request
                                }
                                break;
                            case OBSERVING:
                                // Do nothing, Observers keep themselves to
                                // themselves.
                                break;
                        }
                        packet.setData(b);
                        udpSocket.send(packet);
                    }
                    packet.setLength(b.length);
                }
            } catch (RuntimeException e) {
                LOG.warn("Unexpected runtime exception in ResponderThread", e);
            } catch (IOException e) {
                LOG.warn("Unexpected IO exception in ResponderThread", e);
            } finally {
                LOG.warn("QuorumPeer responder thread exited");
            }
        }
    }

    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ServerState state = ServerState.LOOKING;

    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) AtomicReference<ZabState> zabState = new AtomicReference<>(ZabState.ELECTION);

    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) AtomicReference<SyncMode> syncMode = new AtomicReference<>(SyncMode.NONE);

    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) AtomicReference<String> leaderAddress = new AtomicReference<String>("");

    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) AtomicLong leaderId = new AtomicLong(-1);

    // indicates that a reconfig just committed
    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean reconfigFlag = false;

    public synchronized void setPeerState(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ServerState newState) {
        state = newState;
        if (newState == ServerState.LOOKING) {
            setLeaderAddressAndId(null, -1);
            setZabState(ZabState.ELECTION);
        } else {
            LOG.info("Peer state changed: {}", getDetailedPeerState());
        }
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "org.apache.zookeeper.server.quorum.QuorumPeer.LOG" }, methods = { "info" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getDetailedPeerState" })
    public void setZabState(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ZabState zabState) {
        this.zabState.set(zabState);
        LOG.info("Peer state changed: {}", getDetailedPeerState());
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "org.apache.zookeeper.server.quorum.QuorumPeer.LOG" }, methods = { "info" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getDetailedPeerState" })
    public void setSyncMode(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) SyncMode syncMode) {
        this.syncMode.set(syncMode);
        LOG.info("Peer state changed: {}", getDetailedPeerState());
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.zabState" }, methods = { "get" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ZabState getZabState(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return zabState.get();
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.syncMode" }, methods = { "get" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) SyncMode getSyncMode(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return syncMode.get();
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#1" }, methods = { "getAllHostStrings" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.leaderId" }, methods = { "set" })
    public void setLeaderAddressAndId(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) MultipleAddresses addr,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long newId) {
        if (addr != null) {
            leaderAddress.set(String.join("|", addr.getAllHostStrings()));
        } else {
            leaderAddress.set(null);
        }
        leaderId.set(newId);
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.leaderAddress" }, methods = { "get" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String getLeaderAddress(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "getLeaderId" }) QuorumPeer this) {
        return leaderAddress.get();
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.leaderId" }, methods = { "get" })
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long getLeaderId(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return leaderId.get();
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getPeerState", "getSyncMode", "getZabState" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String getDetailedPeerState(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        final StringBuilder sb = new StringBuilder(getPeerState().toString().toLowerCase());
        final ZabState zabState = getZabState();
        if (!ZabState.ELECTION.equals(zabState)) {
            sb.append(" - ").append(zabState.toString().toLowerCase());
        }
        final SyncMode syncMode = getSyncMode();
        if (!SyncMode.NONE.equals(syncMode)) {
            sb.append(" - ").append(syncMode.toString().toLowerCase());
        }
        return sb.toString();
    }

    public synchronized void reconfigFlagSet(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        reconfigFlag = true;
    }

    public synchronized void reconfigFlagClear(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        reconfigFlag = false;
    }

    @org.checkerframework.dataflow.qual.Pure
    public synchronized  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isReconfigStateChange(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return reconfigFlag;
    }

    @org.checkerframework.dataflow.qual.Pure
    public synchronized @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ServerState getPeerState(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return state;
    }

    DatagramSocket udpSocket;

    private final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) AtomicReference<AddressTuple> myAddrs = new AtomicReference<>();

    /**
     * Resolves hostname for a given server ID.
     *
     * This method resolves hostname for a given server ID in both quorumVerifer
     * and lastSeenQuorumVerifier. If the server ID matches the local server ID,
     * it also updates myAddrs.
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getLastSeenQuorumVerifier", "getQuorumVerifier" })
    public void recreateSocketAddresses(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long id) {
        QuorumVerifier qv = getQuorumVerifier();
        if (qv != null) {
            QuorumServer qs = qv.getAllMembers().get(id);
            if (qs != null) {
                qs.recreateSocketAddresses();
                if (id == getId()) {
                    setAddrs(qs.addr, qs.electionAddr, qs.clientAddr);
                }
            }
        }
        qv = getLastSeenQuorumVerifier();
        if (qv != null) {
            QuorumServer qs = qv.getAllMembers().get(id);
            if (qs != null) {
                qs.recreateSocketAddresses();
            }
        }
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.myAddrs" }, methods = { "get" })
    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) AddressTuple getAddrs(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        AddressTuple addrs = myAddrs.get();
        if (addrs != null) {
            return addrs;
        }
        try {
            synchronized (QV_LOCK) {
                addrs = myAddrs.get();
                while (addrs == null) {
                    QV_LOCK.wait();
                    addrs = myAddrs.get();
                }
                return addrs;
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        }
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getAddrs" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) MultipleAddresses getQuorumAddress(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return getAddrs().quorumAddr;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getAddrs" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) MultipleAddresses getElectionAddress(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return getAddrs().electionAddr;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.myAddrs" }, methods = { "get" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) InetSocketAddress getClientAddress(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        final AddressTuple addrs = myAddrs.get();
        return (addrs == null) ? null : addrs.clientAddr;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.QV_LOCK" }, methods = { "notifyAll" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.myAddrs" }, methods = { "set" })
    private void setAddrs(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) MultipleAddresses quorumAddr, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) MultipleAddresses electionAddr, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) InetSocketAddress clientAddr) {
        synchronized (QV_LOCK) {
            myAddrs.set(new AddressTuple(quorumAddr, electionAddr, clientAddr));
            QV_LOCK.notifyAll();
        }
    }

    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int electionType;

    @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Election electionAlg;

    @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ServerCnxnFactory cnxnFactory;

    @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ServerCnxnFactory secureCnxnFactory;

    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) FileTxnSnapLog logFactory = null;

    private final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumStats quorumStats;

    @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) AdminServer adminServer;

    private final  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean reconfigEnabled;

    public static @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer testingQuorumPeer() throws SaslException {
        return new QuorumPeer();
    }

    public QuorumPeer() throws SaslException {
        super("QuorumPeer");
        quorumStats = new QuorumStats(this);
        jmxRemotePeerBean = new HashMap<Long, RemotePeerBean>();
        adminServer = AdminServerFactory.createAdminServer();
        x509Util = createX509Util();
        initialize();
        reconfigEnabled = QuorumPeerConfig.isReconfigEnabled();
    }

    // VisibleForTesting
    @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumX509Util createX509Util(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return new QuorumX509Util();
    }

    /**
     * For backward compatibility purposes, we instantiate QuorumMaj by default.
     */
    public QuorumPeer(Map<Long, QuorumServer> quorumPeers, File dataDir, File dataLogDir, int electionType, long myid, int tickTime, int initLimit, int syncLimit, int connectToLearnerMasterLimit, ServerCnxnFactory cnxnFactory) throws IOException {
        this(quorumPeers, dataDir, dataLogDir, electionType, myid, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, false, cnxnFactory, new QuorumMaj(quorumPeers));
    }

    public QuorumPeer(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Map<Long, QuorumServer> quorumPeers, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) File dataDir, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) File dataLogDir,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int electionType,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long myid,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int tickTime,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int initLimit,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int syncLimit,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int connectToLearnerMasterLimit,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean quorumListenOnAllIPs, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ServerCnxnFactory cnxnFactory, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumVerifier quorumConfig) throws IOException {
        this();
        this.cnxnFactory = cnxnFactory;
        this.electionType = electionType;
        this.myid = myid;
        this.tickTime = tickTime;
        this.initLimit = initLimit;
        this.syncLimit = syncLimit;
        this.connectToLearnerMasterLimit = connectToLearnerMasterLimit;
        this.quorumListenOnAllIPs = quorumListenOnAllIPs;
        this.logFactory = new FileTxnSnapLog(dataLogDir, dataDir);
        this.zkDb = new ZKDatabase(this.logFactory);
        if (quorumConfig == null) {
            quorumConfig = new QuorumMaj(quorumPeers);
        }
        setQuorumVerifier(quorumConfig, false);
        adminServer = AdminServerFactory.createAdminServer();
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "isQuorumSaslAuthEnabled" })
    public void initialize(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) throws SaslException {
        // init quorum auth server & learner
        if (isQuorumSaslAuthEnabled()) {
            Set<String> authzHosts = new HashSet<String>();
            for (QuorumServer qs : getView().values()) {
                authzHosts.add(qs.hostname);
            }
            authServer = new SaslQuorumAuthServer(isQuorumServerSaslAuthRequired(), quorumServerLoginContext, authzHosts);
            authLearner = new SaslQuorumAuthLearner(isQuorumLearnerSaslAuthRequired(), quorumServicePrincipal, quorumLearnerLoginContext);
        } else {
            authServer = new NullQuorumAuthServer();
            authLearner = new NullQuorumAuthLearner();
        }
    }

    @org.checkerframework.dataflow.qual.Pure
    @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumStats quorumStats() {
        return quorumStats;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getView", "loadDataBase", "start", "startJvmPauseMonitor", "startLeaderElection", "startServerCnxnFactory" })
    public synchronized void start(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        if (!getView().containsKey(myid)) {
            throw new RuntimeException("My id " + myid + " not in the peer list");
        }
        loadDataBase();
        startServerCnxnFactory();
        try {
            adminServer.start();
        } catch (AdminServerException e) {
            LOG.warn("Problem starting AdminServer", e);
            System.out.println(e);
        }
        startLeaderElection();
        startJvmPauseMonitor();
        super.start();
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "readLongFromFile" })
    private void loadDataBase(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        try {
            zkDb.loadDataBase();
            // load the epochs
            long lastProcessedZxid = zkDb.getDataTree().lastProcessedZxid;
            long epochOfZxid = ZxidUtils.getEpochFromZxid(lastProcessedZxid);
            try {
                currentEpoch = readLongFromFile(CURRENT_EPOCH_FILENAME);
            } catch (FileNotFoundException e) {
                // pick a reasonable epoch number
                // this should only happen once when moving to a
                // new code version
                currentEpoch = epochOfZxid;
                LOG.info("{} not found! Creating with a reasonable default of {}. This should only happen when you are upgrading your installation", CURRENT_EPOCH_FILENAME, currentEpoch);
                writeLongToFile(CURRENT_EPOCH_FILENAME, currentEpoch);
            }
            if (epochOfZxid > currentEpoch) {
                throw new IOException("The current epoch, " + ZxidUtils.zxidToString(currentEpoch) + ", is older than the last zxid, " + lastProcessedZxid);
            }
            try {
                acceptedEpoch = readLongFromFile(ACCEPTED_EPOCH_FILENAME);
            } catch (FileNotFoundException e) {
                // pick a reasonable epoch number
                // this should only happen once when moving to a
                // new code version
                acceptedEpoch = epochOfZxid;
                LOG.info("{} not found! Creating with a reasonable default of {}. This should only happen when you are upgrading your installation", ACCEPTED_EPOCH_FILENAME, acceptedEpoch);
                writeLongToFile(ACCEPTED_EPOCH_FILENAME, acceptedEpoch);
            }
            if (acceptedEpoch < currentEpoch) {
                throw new IOException("The accepted epoch, " + ZxidUtils.zxidToString(acceptedEpoch) + " is less than the current epoch, " + ZxidUtils.zxidToString(currentEpoch));
            }
        } catch (IOException ie) {
            LOG.error("Unable to load database on disk", ie);
            throw new RuntimeException("Unable to run quorum server ", ie);
        }
    }

    ResponderThread responder;

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.responder" }, methods = { "interrupt" })
    public synchronized void stopLeaderElection() {
        responder.running = false;
        responder.interrupt();
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "createElectionAlgorithm", "getPeerState" })
    public synchronized void startLeaderElection(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        try {
            if (getPeerState() == ServerState.LOOKING) {
                currentVote = new Vote(myid, getLastLoggedZxid(), getCurrentEpoch());
            }
        } catch (IOException e) {
            RuntimeException re = new RuntimeException(e.getMessage());
            re.setStackTrace(e.getStackTrace());
            throw re;
        }
        this.electionAlg = createElectionAlgorithm(electionType);
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.jvmPauseMonitor" }, methods = { "serviceStart" })
    private void startJvmPauseMonitor(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        if (this.jvmPauseMonitor != null) {
            this.jvmPauseMonitor.serviceStart();
        }
    }

    /**
     * Count the number of nodes in the map that could be followers.
     * @param peers
     * @return The number of followers in the map
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#1" }, methods = { "values" })
    @org.checkerframework.dataflow.qual.SideEffectFree
    protected static  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int countParticipants(Map<Long, QuorumServer> peers) {
        int count = 0;
        for (QuorumServer q : peers.values()) {
            if (q.type == LearnerType.PARTICIPANT) {
                count++;
            }
        }
        return count;
    }

    /**
     * This constructor is only used by the existing unit test code.
     * It defaults to FileLogProvider persistence provider.
     */
    public QuorumPeer(Map<Long, QuorumServer> quorumPeers, File snapDir, File logDir, int clientPort, int electionAlg, long myid, int tickTime, int initLimit, int syncLimit, int connectToLearnerMasterLimit) throws IOException {
        this(quorumPeers, snapDir, logDir, electionAlg, myid, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, false, ServerCnxnFactory.createFactory(getClientAddress(quorumPeers, myid, clientPort), -1), new QuorumMaj(quorumPeers));
    }

    /**
     * This constructor is only used by the existing unit test code.
     * It defaults to FileLogProvider persistence provider.
     */
    public QuorumPeer(Map<Long, QuorumServer> quorumPeers, File snapDir, File logDir, int clientPort, int electionAlg, long myid, int tickTime, int initLimit, int syncLimit, int connectToLearnerMasterLimit, QuorumVerifier quorumConfig) throws IOException {
        this(quorumPeers, snapDir, logDir, electionAlg, myid, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, false, ServerCnxnFactory.createFactory(getClientAddress(quorumPeers, myid, clientPort), -1), quorumConfig);
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#1" }, methods = { "get" })
    private static @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) InetSocketAddress getClientAddress(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Map<Long, QuorumServer> quorumPeers,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long myid,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int clientPort) throws IOException {
        QuorumServer quorumServer = quorumPeers.get(myid);
        if (null == quorumServer) {
            throw new IOException("No QuorumServer correspoding to myid " + myid);
        }
        if (null == quorumServer.clientAddr) {
            return new InetSocketAddress(clientPort);
        }
        if (quorumServer.clientAddr.getPort() != clientPort) {
            throw new IOException("QuorumServer port " + quorumServer.clientAddr.getPort() + " does not match with given port " + clientPort);
        }
        return quorumServer.clientAddr;
    }

    /**
     * returns the highest zxid that this host has seen
     *
     * @return the highest zxid for this host
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "loadDataBase" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.zkDb" }, methods = { "getDataTreeLastProcessedZxid" })
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long getLastLoggedZxid(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        if (!zkDb.isInitialized()) {
            loadDataBase();
        }
        return zkDb.getDataTreeLastProcessedZxid();
    }

    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Follower follower;

    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Leader leader;

    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Observer observer;

    protected @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Follower makeFollower(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) FileTxnSnapLog logFactory) throws IOException {
        return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.zkDb));
    }

    protected @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Leader makeLeader(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) FileTxnSnapLog logFactory) throws IOException, X509Exception {
        return new Leader(this, new LeaderZooKeeperServer(logFactory, this, this.zkDb));
    }

    protected @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Observer makeObserver(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) FileTxnSnapLog logFactory) throws IOException {
        return new Observer(this, new ObserverZooKeeperServer(logFactory, this, this.zkDb));
    }

    protected @org.checkerframework.checker.calledmethods.qual.CalledMethods({ "start" }) Election createElectionAlgorithm(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int electionAlgorithm) {
        Election le = null;
        //TODO: use a factory rather than a switch
        switch(electionAlgorithm) {
            case 1:
                throw new UnsupportedOperationException("Election Algorithm 1 is not supported.");
            case 2:
                throw new UnsupportedOperationException("Election Algorithm 2 is not supported.");
            case 3:
                QuorumCnxManager qcm = createCnxnManager();
                QuorumCnxManager oldQcm = qcmRef.getAndSet(qcm);
                if (oldQcm != null) {
                    LOG.warn("Clobbering already-set QuorumCnxManager (restarting leader election?)");
                    oldQcm.halt();
                }
                QuorumCnxManager.Listener listener = qcm.listener;
                if (listener != null) {
                    listener.start();
                    FastLeaderElection fle = new FastLeaderElection(this, qcm);
                    fle.start();
                    le = fle;
                } else {
                    LOG.error("Null listener when initializing cnx manager");
                }
                break;
            default:
                assert false;
        }
        return le;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "org.apache.zookeeper.server.quorum.QuorumPeer.LOG" }, methods = { "debug" })
    protected @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Election makeLEStrategy(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        LOG.debug("Initializing leader election protocol...");
        return electionAlg;
    }

    protected synchronized void setLeader(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Leader newLeader) {
        leader = newLeader;
    }

    protected synchronized void setFollower(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Follower newFollower) {
        follower = newFollower;
    }

    protected synchronized void setObserver(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Observer newObserver) {
        observer = newObserver;
    }

    @org.checkerframework.dataflow.qual.Pure
    public synchronized @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ZooKeeperServer getActiveServer() {
        if (leader != null) {
            return leader.zk;
        } else if (follower != null) {
            return follower.zk;
        } else if (observer != null) {
            return observer.zk;
        }
        return null;
    }

     @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean shuttingDownLE = false;

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "org.apache.zookeeper.server.quorum.QuorumPeer.LOG" }, methods = { "debug", "warn" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "updateThreadName" })
    @org.checkerframework.framework.qual.EnsuresQualifier(expression = { "this.jmxLocalPeerBean" }, qualifier = org.checkerframework.checker.calledmethods.qual.CalledMethodsBottom.class)
    @org.checkerframework.framework.qual.EnsuresQualifier(expression = { "this.jmxQuorumBean" }, qualifier = org.checkerframework.checker.calledmethods.qual.CalledMethodsBottom.class)
    @org.checkerframework.framework.qual.EnsuresQualifier(expression = { "this.jmxRemotePeerBean" }, qualifier = org.checkerframework.checker.calledmethods.qual.CalledMethodsBottom.class)
    public void run(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        updateThreadName();
        LOG.debug("Starting quorum peer");
        try {
            jmxQuorumBean = new QuorumBean(this);
            MBeanRegistry.getInstance().register(jmxQuorumBean, null);
            for (QuorumServer s : getView().values()) {
                ZKMBeanInfo p;
                if (getId() == s.id) {
                    p = jmxLocalPeerBean = new LocalPeerBean(this);
                    try {
                        MBeanRegistry.getInstance().register(p, jmxQuorumBean);
                    } catch (Exception e) {
                        LOG.warn("Failed to register with JMX", e);
                        jmxLocalPeerBean = null;
                    }
                } else {
                    RemotePeerBean rBean = new RemotePeerBean(this, s);
                    try {
                        MBeanRegistry.getInstance().register(rBean, jmxQuorumBean);
                        jmxRemotePeerBean.put(s.id, rBean);
                    } catch (Exception e) {
                        LOG.warn("Failed to register with JMX", e);
                    }
                }
            }
        } catch (Exception e) {
            LOG.warn("Failed to register with JMX", e);
            jmxQuorumBean = null;
        }
        try {
            /*
             * Main loop
             */
            while (running) {
                switch(getPeerState()) {
                    case LOOKING:
                        LOG.info("LOOKING");
                        ServerMetrics.getMetrics().LOOKING_COUNT.add(1);
                        if (Boolean.getBoolean("readonlymode.enabled")) {
                            LOG.info("Attempting to start ReadOnlyZooKeeperServer");
                            // Create read-only server but don't start it immediately
                            final ReadOnlyZooKeeperServer roZk = new ReadOnlyZooKeeperServer(logFactory, this, this.zkDb);
                            // Instead of starting roZk immediately, wait some grace
                            // period before we decide we're partitioned.
                            //
                            // Thread is used here because otherwise it would require
                            // changes in each of election strategy classes which is
                            // unnecessary code coupling.
                            Thread roZkMgr = new Thread() {

                                public void run() {
                                    try {
                                        // lower-bound grace period to 2 secs
                                        sleep(Math.max(2000, tickTime));
                                        if (ServerState.LOOKING.equals(getPeerState())) {
                                            roZk.startup();
                                        }
                                    } catch (InterruptedException e) {
                                        LOG.info("Interrupted while attempting to start ReadOnlyZooKeeperServer, not started");
                                    } catch (Exception e) {
                                        LOG.error("FAILED to start ReadOnlyZooKeeperServer", e);
                                    }
                                }
                            };
                            try {
                                roZkMgr.start();
                                reconfigFlagClear();
                                if (shuttingDownLE) {
                                    shuttingDownLE = false;
                                    startLeaderElection();
                                }
                                setCurrentVote(makeLEStrategy().lookForLeader());
                            } catch (Exception e) {
                                LOG.warn("Unexpected exception", e);
                                setPeerState(ServerState.LOOKING);
                            } finally {
                                // If the thread is in the the grace period, interrupt
                                // to come out of waiting.
                                roZkMgr.interrupt();
                                roZk.shutdown();
                            }
                        } else {
                            try {
                                reconfigFlagClear();
                                if (shuttingDownLE) {
                                    shuttingDownLE = false;
                                    startLeaderElection();
                                }
                                setCurrentVote(makeLEStrategy().lookForLeader());
                            } catch (Exception e) {
                                LOG.warn("Unexpected exception", e);
                                setPeerState(ServerState.LOOKING);
                            }
                        }
                        break;
                    case OBSERVING:
                        try {
                            LOG.info("OBSERVING");
                            setObserver(makeObserver(logFactory));
                            observer.observeLeader();
                        } catch (Exception e) {
                            LOG.warn("Unexpected exception", e);
                        } finally {
                            observer.shutdown();
                            setObserver(null);
                            updateServerState();
                            // Add delay jitter before we switch to LOOKING
                            // state to reduce the load of ObserverMaster
                            if (isRunning()) {
                                Observer.waitForObserverElectionDelay();
                            }
                        }
                        break;
                    case FOLLOWING:
                        try {
                            LOG.info("FOLLOWING");
                            setFollower(makeFollower(logFactory));
                            follower.followLeader();
                        } catch (Exception e) {
                            LOG.warn("Unexpected exception", e);
                        } finally {
                            follower.shutdown();
                            setFollower(null);
                            updateServerState();
                        }
                        break;
                    case LEADING:
                        LOG.info("LEADING");
                        try {
                            setLeader(makeLeader(logFactory));
                            leader.lead();
                            setLeader(null);
                        } catch (Exception e) {
                            LOG.warn("Unexpected exception", e);
                        } finally {
                            if (leader != null) {
                                leader.shutdown("Forcing shutdown");
                                setLeader(null);
                            }
                            updateServerState();
                        }
                        break;
                }
            }
        } finally {
            LOG.warn("QuorumPeer main thread exited");
            MBeanRegistry instance = MBeanRegistry.getInstance();
            instance.unregister(jmxQuorumBean);
            instance.unregister(jmxLocalPeerBean);
            for (RemotePeerBean remotePeerBean : jmxRemotePeerBean.values()) {
                instance.unregister(remotePeerBean);
            }
            jmxQuorumBean = null;
            jmxLocalPeerBean = null;
            jmxRemotePeerBean = null;
        }
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "setPeerState" })
    private synchronized void updateServerState(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        if (!reconfigFlag) {
            setPeerState(ServerState.LOOKING);
            LOG.warn("PeerState set to LOOKING");
            return;
        }
        if (getId() == getCurrentVote().getId()) {
            setPeerState(ServerState.LEADING);
            LOG.debug("PeerState set to LEADING");
        } else if (getLearnerType() == LearnerType.PARTICIPANT) {
            setPeerState(ServerState.FOLLOWING);
            LOG.debug("PeerState set to FOLLOWING");
        } else if (getLearnerType() == LearnerType.OBSERVER) {
            setPeerState(ServerState.OBSERVING);
            LOG.debug("PeerState set to OBSERVER");
        } else {
            // currently shouldn't happen since there are only 2 learner types
            setPeerState(ServerState.LOOKING);
            LOG.debug("Should not be here");
        }
        reconfigFlag = false;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getElectionAlg", "shutdownServerCnxnFactory" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.x509Util" }, methods = { "close" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "x509Util" }, methods = { "close" })
    public void shutdown() {
        running = false;
        x509Util.close();
        if (leader != null) {
            leader.shutdown("quorum Peer shutdown");
        }
        if (follower != null) {
            follower.shutdown();
        }
        shutdownServerCnxnFactory();
        if (udpSocket != null) {
            udpSocket.close();
        }
        if (jvmPauseMonitor != null) {
            jvmPauseMonitor.serviceStop();
        }
        try {
            adminServer.shutdown();
        } catch (AdminServerException e) {
            LOG.warn("Problem stopping AdminServer", e);
        }
        if (getElectionAlg() != null) {
            this.interrupt();
            getElectionAlg().shutdown();
        }
        try {
            zkDb.close();
        } catch (IOException ie) {
            LOG.warn("Error closing logs ", ie);
        }
    }

    /**
     * A 'view' is a node's current opinion of the membership of the entire
     * ensemble.
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getQuorumVerifier" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Map<Long, QuorumPeer.QuorumServer> getView(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return Collections.unmodifiableMap(getQuorumVerifier().getAllMembers());
    }

    /**
     * Observers are not contained in this view, only nodes with
     * PeerType=PARTICIPANT.
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getQuorumVerifier" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Map<Long, QuorumPeer.QuorumServer> getVotingView(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return getQuorumVerifier().getVotingMembers();
    }

    /**
     * Returns only observers, no followers.
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getQuorumVerifier" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Map<Long, QuorumPeer.QuorumServer> getObservingView() {
        return getQuorumVerifier().getObservingMembers();
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getLastSeenQuorumVerifier", "getQuorumVerifier" })
    public synchronized @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Set<Long> getCurrentAndNextConfigVoters(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        Set<Long> voterIds = new HashSet<Long>(getQuorumVerifier().getVotingMembers().keySet());
        if (getLastSeenQuorumVerifier() != null) {
            voterIds.addAll(getLastSeenQuorumVerifier().getVotingMembers().keySet());
        }
        return voterIds;
    }

    /**
     * Check if a node is in the current view. With static membership, the
     * result of this check will never change; only when dynamic membership
     * is introduced will this be more useful.
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getView" })
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean viewContains(Long sid) {
        return this.getView().containsKey(sid);
    }

    /**
     * Only used by QuorumStats at the moment
     */
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) [] getQuorumPeers(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        List<String> l = new ArrayList<String>();
        synchronized (this) {
            if (leader != null) {
                for (LearnerHandler fh : leader.getLearners()) {
                    if (fh.getSocket() != null) {
                        String s = formatInetAddr((InetSocketAddress) fh.getSocket().getRemoteSocketAddress());
                        if (leader.isLearnerSynced(fh)) {
                            s += "*";
                        }
                        l.add(s);
                    }
                }
            } else if (follower != null) {
                l.add(formatInetAddr((InetSocketAddress) follower.sock.getRemoteSocketAddress()));
            }
        }
        return l.toArray(new String[0]);
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getPeerState" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String getServerState(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        switch(getPeerState()) {
            case LOOKING:
                return QuorumStats.Provider.LOOKING_STATE;
            case LEADING:
                return QuorumStats.Provider.LEADING_STATE;
            case FOLLOWING:
                return QuorumStats.Provider.FOLLOWING_STATE;
            case OBSERVING:
                return QuorumStats.Provider.OBSERVING_STATE;
        }
        return QuorumStats.Provider.UNKNOWN_STATE;
    }

    /**
     * set the id of this quorum peer.
     */
    public void setMyid(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "setElectionType" }) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long myid) {
        this.myid = myid;
    }

    public void setInitialConfig(String initialConfig) {
        this.initialConfig = initialConfig;
    }

    @org.checkerframework.dataflow.qual.Pure
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String getInitialConfig(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return initialConfig;
    }

    /**
     * Get the number of milliseconds of each tick
     */
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int getTickTime(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return tickTime;
    }

    /**
     * Set the number of milliseconds of each tick
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "org.apache.zookeeper.server.quorum.QuorumPeer.LOG" }, methods = { "info" })
    public void setTickTime(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "setMyid" }) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int tickTime) {
        LOG.info("tickTime set to {}", tickTime);
        this.tickTime = tickTime;
    }

    /**
     * Maximum number of connections allowed from particular host (ip)
     */
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int getMaxClientCnxnsPerHost(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        if (cnxnFactory != null) {
            return cnxnFactory.getMaxClientCnxnsPerHost();
        }
        if (secureCnxnFactory != null) {
            return secureCnxnFactory.getMaxClientCnxnsPerHost();
        }
        return -1;
    }

    /**
     * Whether local sessions are enabled
     */
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean areLocalSessionsEnabled(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return localSessionsEnabled;
    }

    /**
     * Whether to enable local sessions
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "org.apache.zookeeper.server.quorum.QuorumPeer.LOG" }, methods = { "info" })
    public void enableLocalSessions(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "setTxnFactory" }) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean flag) {
        LOG.info("Local sessions {}", (flag ? "enabled" : "disabled"));
        localSessionsEnabled = flag;
    }

    /**
     * Whether local sessions are allowed to upgrade to global sessions
     */
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isLocalSessionsUpgradingEnabled(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return localSessionsUpgradingEnabled;
    }

    /**
     * Whether to allow local sessions to upgrade to global sessions
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "org.apache.zookeeper.server.quorum.QuorumPeer.LOG" }, methods = { "info" })
    public void enableLocalSessionsUpgrading(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "enableLocalSessions" }) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean flag) {
        LOG.info("Local session upgrading {}", (flag ? "enabled" : "disabled"));
        localSessionsUpgradingEnabled = flag;
    }

    /**
     * minimum session timeout in milliseconds
     */
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int getMinSessionTimeout(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return minSessionTimeout;
    }

    /**
     * minimum session timeout in milliseconds
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "org.apache.zookeeper.server.quorum.QuorumPeer.LOG" }, methods = { "info" })
    public void setMinSessionTimeout(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "setTickTime" }) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int min) {
        LOG.info("minSessionTimeout set to {}", min);
        this.minSessionTimeout = min;
    }

    /**
     * maximum session timeout in milliseconds
     */
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int getMaxSessionTimeout(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return maxSessionTimeout;
    }

    /**
     * maximum session timeout in milliseconds
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "org.apache.zookeeper.server.quorum.QuorumPeer.LOG" }, methods = { "info" })
    public void setMaxSessionTimeout(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "setMinSessionTimeout" }) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int max) {
        LOG.info("maxSessionTimeout set to {}", max);
        this.maxSessionTimeout = max;
    }

    /**
     * The server socket's listen backlog length
     */
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int getClientPortListenBacklog() {
        return this.clientPortListenBacklog;
    }

    /**
     * Sets the server socket's listen backlog length.
     */
    public void setClientPortListenBacklog(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "setConfigFileName" }) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int backlog) {
        this.clientPortListenBacklog = backlog;
    }

    /**
     * Get the number of ticks that the initial synchronization phase can take
     */
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int getInitLimit(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return initLimit;
    }

    /**
     * Set the number of ticks that the initial synchronization phase can take
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "org.apache.zookeeper.server.quorum.QuorumPeer.LOG" }, methods = { "info" })
    public void setInitLimit(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int initLimit) {
        LOG.info("initLimit set to {}", initLimit);
        this.initLimit = initLimit;
    }

    /**
     * Get the current tick
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.tick" }, methods = { "get" })
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int getTick(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return tick.get();
    }

    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumVerifier configFromString(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String s) throws IOException, ConfigException {
        Properties props = new Properties();
        props.load(new StringReader(s));
        return QuorumPeerConfig.parseDynamicConfig(props, electionType, false, false);
    }

    /**
     * Return QuorumVerifier object for the last committed configuration.
     */
    @org.checkerframework.dataflow.qual.Pure
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumVerifier getQuorumVerifier(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        synchronized (QV_LOCK) {
            return quorumVerifier;
        }
    }

    /**
     * Return QuorumVerifier object for the last proposed configuration.
     */
    @org.checkerframework.dataflow.qual.Pure
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumVerifier getLastSeenQuorumVerifier(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        synchronized (QV_LOCK) {
            return lastSeenQuorumVerifier;
        }
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#1" }, methods = { "equals" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getElectionAlg", "startLeaderElection" })
    public synchronized void restartLeaderElection(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({ "equals", "getVersion" }) QuorumVerifier qvOLD, @org.checkerframework.checker.calledmethods.qual.CalledMethods({ "getAllMembers", "getVersion" }) QuorumVerifier qvNEW) {
        if (qvOLD == null || !qvOLD.equals(qvNEW)) {
            LOG.warn("Restarting Leader Election");
            getElectionAlg().shutdown();
            shuttingDownLE = false;
            startLeaderElection();
        }
    }

    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String getNextDynamicConfigFilename(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        if (configFilename == null) {
            LOG.warn("configFilename is null! This should only happen in tests.");
            return null;
        }
        return configFilename + QuorumPeerConfig.nextDynamicConfigFileSuffix;
    }

    // On entry to this method, qcm must be non-null and the locks on both qcm and QV_LOCK
    // must be held.  We don't want quorumVerifier/lastSeenQuorumVerifier to change out from
    // under us, so we have to hold QV_LOCK; and since the call to qcm.connectOne() will take
    // the lock on qcm (and take QV_LOCK again inside that), the caller needs to have taken
    // qcm outside QV_LOCK to avoid a deadlock against other callers of qcm.connectOne().
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getId" })
    private void connectNewPeers(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumCnxManager qcm) {
        if (quorumVerifier != null && lastSeenQuorumVerifier != null) {
            Map<Long, QuorumServer> committedView = quorumVerifier.getAllMembers();
            for (Entry<Long, QuorumServer> e : lastSeenQuorumVerifier.getAllMembers().entrySet()) {
                if (e.getKey() != getId() && !committedView.containsKey(e.getKey())) {
                    qcm.connectOne(e.getKey());
                }
            }
        }
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "isReconfigEnabled" })
    public void setLastSeenQuorumVerifier(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumVerifier qv,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean writeToDisk) {
        if (!isReconfigEnabled()) {
            LOG.info("Dynamic reconfig is disabled, we don't store the last seen config.");
            return;
        }
        // If qcm is non-null, we may call qcm.connectOne(), which will take the lock on qcm
        // and then take QV_LOCK.  Take the locks in the same order to ensure that we don't
        // deadlock against other callers of connectOne().  If qcmRef gets set in another
        // thread while we're inside the synchronized block, that does no harm; if we didn't
        // take a lock on qcm (because it was null when we sampled it), we won't call
        // connectOne() on it.  (Use of an AtomicReference is enough to guarantee visibility
        // of updates that provably happen in another thread before entering this method.)
        QuorumCnxManager qcm = qcmRef.get();
        Object outerLockObject = (qcm != null) ? qcm : QV_LOCK;
        synchronized (outerLockObject) {
            synchronized (QV_LOCK) {
                if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() > qv.getVersion()) {
                    LOG.error("setLastSeenQuorumVerifier called with stale config " + qv.getVersion() + ". Current version: " + quorumVerifier.getVersion());
                }
                // assuming that a version uniquely identifies a configuration, so if
                // version is the same, nothing to do here.
                if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() == qv.getVersion()) {
                    return;
                }
                lastSeenQuorumVerifier = qv;
                if (qcm != null) {
                    connectNewPeers(qcm);
                }
                if (writeToDisk) {
                    try {
                        String fileName = getNextDynamicConfigFilename();
                        if (fileName != null) {
                            QuorumPeerConfig.writeDynamicConfig(fileName, qv, true);
                        }
                    } catch (IOException e) {
                        LOG.error("Error writing next dynamic config file to disk", e);
                    }
                }
            }
        }
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#1" }, methods = { "getVersion" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getId" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumVerifier setQuorumVerifier(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumVerifier qv,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean writeToDisk) {
        synchronized (QV_LOCK) {
            if ((quorumVerifier != null) && (quorumVerifier.getVersion() >= qv.getVersion())) {
                // this is normal. For example - server found out about new config through FastLeaderElection gossiping
                // and then got the same config in UPTODATE message so its already known
                LOG.debug("{} setQuorumVerifier called with known or old config {}. Current version: {}", getId(), qv.getVersion(), quorumVerifier.getVersion());
                return quorumVerifier;
            }
            QuorumVerifier prevQV = quorumVerifier;
            quorumVerifier = qv;
            if (lastSeenQuorumVerifier == null || (qv.getVersion() > lastSeenQuorumVerifier.getVersion())) {
                lastSeenQuorumVerifier = qv;
            }
            if (writeToDisk) {
                // some tests initialize QuorumPeer without a static config file
                if (configFilename != null) {
                    try {
                        String dynamicConfigFilename = makeDynamicConfigFilename(qv.getVersion());
                        QuorumPeerConfig.writeDynamicConfig(dynamicConfigFilename, qv, false);
                        QuorumPeerConfig.editStaticConfig(configFilename, dynamicConfigFilename, needEraseClientInfoFromStaticConfig());
                    } catch (IOException e) {
                        LOG.error("Error closing file", e);
                    }
                } else {
                    LOG.info("writeToDisk == true but configFilename == null");
                }
            }
            if (qv.getVersion() == lastSeenQuorumVerifier.getVersion()) {
                QuorumPeerConfig.deleteFile(getNextDynamicConfigFilename());
            }
            QuorumServer qs = qv.getAllMembers().get(getId());
            if (qs != null) {
                setAddrs(qs.addr, qs.electionAddr, qs.clientAddr);
            }
            updateObserverMasterList();
            return prevQV;
        }
    }

    @org.checkerframework.dataflow.qual.SideEffectFree
    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String makeDynamicConfigFilename(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long version) {
        return configFilename + ".dynamic." + Long.toHexString(version);
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getId" })
    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean needEraseClientInfoFromStaticConfig(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        QuorumServer server = quorumVerifier.getAllMembers().get(getId());
        return (server != null && server.clientAddr != null && !server.isClientAddrFromStatic);
    }

    /**
     * Get an instance of LeaderElection
     */
    @org.checkerframework.dataflow.qual.Pure
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Election getElectionAlg(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return electionAlg;
    }

    /**
     * Get the synclimit
     */
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int getSyncLimit(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return syncLimit;
    }

    /**
     * Set the synclimit
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "org.apache.zookeeper.server.quorum.QuorumPeer.LOG" }, methods = { "info" })
    public void setSyncLimit(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int syncLimit) {
        LOG.info("syncLimit set to {}", syncLimit);
        this.syncLimit = syncLimit;
    }

    /**
     * Get the connectToLearnerMasterLimit
     */
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int getConnectToLearnerMasterLimit() {
        return connectToLearnerMasterLimit;
    }

    /**
     * Set the connectToLearnerMasterLimit
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "org.apache.zookeeper.server.quorum.QuorumPeer.LOG" }, methods = { "info" })
    public void setConnectToLearnerMasterLimit(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "setSyncLimit" }) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int connectToLearnerMasterLimit) {
        LOG.info("connectToLearnerMasterLimit set to {}", connectToLearnerMasterLimit);
        this.connectToLearnerMasterLimit = connectToLearnerMasterLimit;
    }

    /**
     * The syncEnabled can also be set via a system property.
     */
    public static final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String SYNC_ENABLED = "zookeeper.observer.syncEnabled";

    /**
     * Return syncEnabled.
     *
     * @return
     */
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean getSyncEnabled(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        if (System.getProperty(SYNC_ENABLED) != null) {
            LOG.info("{}={}", SYNC_ENABLED, Boolean.getBoolean(SYNC_ENABLED));
            return Boolean.getBoolean(SYNC_ENABLED);
        } else {
            return syncEnabled;
        }
    }

    /**
     * Set syncEnabled.
     *
     * @param syncEnabled
     */
    public void setSyncEnabled(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "setLearnerType" }) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean syncEnabled) {
        this.syncEnabled = syncEnabled;
    }

    /**
     * Gets the election type
     */
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int getElectionType(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return electionType;
    }

    /**
     * Sets the election type
     */
    public void setElectionType(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "enableLocalSessionsUpgrading" }) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int electionType) {
        this.electionType = electionType;
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean getQuorumListenOnAllIPs(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return quorumListenOnAllIPs;
    }

    public void setQuorumListenOnAllIPs(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "setSyncEnabled" }) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean quorumListenOnAllIPs) {
        this.quorumListenOnAllIPs = quorumListenOnAllIPs;
    }

    public void setCnxnFactory(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "initConfigInZKDatabase" }) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({ "configure" }) ServerCnxnFactory cnxnFactory) {
        this.cnxnFactory = cnxnFactory;
    }

    public void setSecureCnxnFactory(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "setCnxnFactory" }) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({ "configure" }) ServerCnxnFactory secureCnxnFactory) {
        this.secureCnxnFactory = secureCnxnFactory;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "org.apache.zookeeper.server.quorum.QuorumPeer.LOG" }, methods = { "info" })
    public void setSslQuorum(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "setSecureCnxnFactory" }) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean sslQuorum) {
        if (sslQuorum) {
            LOG.info("Using TLS encrypted quorum communication");
        } else {
            LOG.info("Using insecure (non-TLS) quorum communication");
        }
        this.sslQuorum = sslQuorum;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "org.apache.zookeeper.server.quorum.QuorumPeer.LOG" }, methods = { "info" })
    public void setUsePortUnification(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "setSslQuorum" }) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean shouldUsePortUnification) {
        LOG.info("Port unification {}", shouldUsePortUnification ? "enabled" : "disabled");
        this.shouldUsePortUnification = shouldUsePortUnification;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.secureCnxnFactory" }, methods = { "start" })
    private void startServerCnxnFactory(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        if (cnxnFactory != null) {
            cnxnFactory.start();
        }
        if (secureCnxnFactory != null) {
            secureCnxnFactory.start();
        }
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.secureCnxnFactory" }, methods = { "shutdown" })
    private void shutdownServerCnxnFactory(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        if (cnxnFactory != null) {
            cnxnFactory.shutdown();
        }
        if (secureCnxnFactory != null) {
            secureCnxnFactory.shutdown();
        }
    }

    // Leader and learner will control the zookeeper server and pass it into QuorumPeer.
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.secureCnxnFactory" }, methods = { "setZooKeeperServer" })
    public void setZooKeeperServer(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ZooKeeperServer zks) {
        if (cnxnFactory != null) {
            cnxnFactory.setZooKeeperServer(zks);
        }
        if (secureCnxnFactory != null) {
            secureCnxnFactory.setZooKeeperServer(zks);
        }
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.secureCnxnFactory" }, methods = { "closeAll" })
    public void closeAllConnections(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "setZooKeeperServer" }) QuorumPeer this) {
        if (cnxnFactory != null) {
            cnxnFactory.closeAll(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);
        }
        if (secureCnxnFactory != null) {
            secureCnxnFactory.closeAll(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);
        }
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.cnxnFactory" }, methods = { "getLocalPort" })
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int getClientPort() {
        if (cnxnFactory != null) {
            return cnxnFactory.getLocalPort();
        }
        return -1;
    }

    public void setTxnFactory(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) FileTxnSnapLog factory) {
        this.logFactory = factory;
    }

    @org.checkerframework.dataflow.qual.Pure
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) FileTxnSnapLog getTxnFactory(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "setClientPortListenBacklog" }) QuorumPeer this) {
        return this.logFactory;
    }

    /**
     * set zk database for this node
     * @param database
     */
    public void setZKDatabase(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "setClientPortListenBacklog" }) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ZKDatabase database) {
        this.zkDb = database;
    }

    @org.checkerframework.dataflow.qual.Pure
    protected @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ZKDatabase getZkDb() {
        return zkDb;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getQuorumVerifier" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.zkDb" }, methods = { "initConfigInZKDatabase" })
    public synchronized void initConfigInZKDatabase(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        if (zkDb != null) {
            zkDb.initConfigInZKDatabase(getQuorumVerifier());
        }
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isRunning(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return running;
    }

    /**
     * get reference to QuorumCnxManager
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.qcmRef" }, methods = { "get" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumCnxManager getQuorumCnxManager() {
        return qcmRef.get();
    }

    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long readLongFromFile(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String name) throws IOException {
        File file = new File(logFactory.getSnapDir(), name);
        BufferedReader br = new BufferedReader(new FileReader(file));
        String line = "";
        try {
            line = br.readLine();
            return Long.parseLong(line);
        } catch (NumberFormatException e) {
            throw new IOException("Found " + line + " in " + file);
        } finally {
            br.close();
        }
    }

    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long acceptedEpoch = -1;

    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long currentEpoch = -1;

    public static final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String CURRENT_EPOCH_FILENAME = "currentEpoch";

    public static final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String ACCEPTED_EPOCH_FILENAME = "acceptedEpoch";

    /**
     * Write a long value to disk atomically. Either succeeds or an exception
     * is thrown.
     * @param name file name to write the long to
     * @param value the long value to write to the named file
     * @throws IOException if the file cannot be written atomically
     */
    // visibleForTest
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.logFactory" }, methods = { "getSnapDir" })
    void writeLongToFile(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String name, final  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long value) throws IOException {
        File file = new File(logFactory.getSnapDir(), name);
        new AtomicFileWritingIdiom(file, new WriterStatement() {

            public void write(Writer bw) throws IOException {
                bw.write(Long.toString(value));
            }
        });
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "readLongFromFile" })
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long getCurrentEpoch(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) throws IOException {
        if (currentEpoch == -1) {
            currentEpoch = readLongFromFile(CURRENT_EPOCH_FILENAME);
        }
        return currentEpoch;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "readLongFromFile" })
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long getAcceptedEpoch(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) throws IOException {
        if (acceptedEpoch == -1) {
            acceptedEpoch = readLongFromFile(ACCEPTED_EPOCH_FILENAME);
        }
        return acceptedEpoch;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "writeLongToFile" })
    public void setCurrentEpoch(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long e) throws IOException {
        writeLongToFile(CURRENT_EPOCH_FILENAME, e);
        currentEpoch = e;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "writeLongToFile" })
    public void setAcceptedEpoch(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long e) throws IOException {
        writeLongToFile(ACCEPTED_EPOCH_FILENAME, e);
        acceptedEpoch = e;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "isReconfigEnabled" })
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean processReconfig(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumVerifier qv, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Long suggestedLeaderId, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Long zxid,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean restartLE) {
        if (!isReconfigEnabled()) {
            LOG.debug("Reconfig feature is disabled, skip reconfig processing.");
            return false;
        }
        InetSocketAddress oldClientAddr = getClientAddress();
        // update last committed quorum verifier, write the new config to disk
        // and restart leader election if config changed.
        QuorumVerifier prevQV = setQuorumVerifier(qv, true);
        // There is no log record for the initial config, thus after syncing
        // with leader
        // /zookeeper/config is empty! it is also possible that last committed
        // config is propagated during leader election
        // without the propagation the corresponding log records.
        // so we should explicitly do this (this is not necessary when we're
        // already a Follower/Observer, only
        // for Learner):
        initConfigInZKDatabase();
        if (prevQV.getVersion() < qv.getVersion() && !prevQV.equals(qv)) {
            Map<Long, QuorumServer> newMembers = qv.getAllMembers();
            updateRemotePeerMXBeans(newMembers);
            if (restartLE) {
                restartLeaderElection(prevQV, qv);
            }
            QuorumServer myNewQS = newMembers.get(getId());
            if (myNewQS != null && myNewQS.clientAddr != null && !myNewQS.clientAddr.equals(oldClientAddr)) {
                cnxnFactory.reconfigure(myNewQS.clientAddr);
                updateThreadName();
            }
            boolean roleChange = updateLearnerType(qv);
            boolean leaderChange = false;
            if (suggestedLeaderId != null) {
                // zxid should be non-null too
                leaderChange = updateVote(suggestedLeaderId, zxid);
            } else {
                long currentLeaderId = getCurrentVote().getId();
                QuorumServer myleaderInCurQV = prevQV.getVotingMembers().get(currentLeaderId);
                QuorumServer myleaderInNewQV = qv.getVotingMembers().get(currentLeaderId);
                leaderChange = (myleaderInCurQV == null || myleaderInCurQV.addr == null || myleaderInNewQV == null || !myleaderInCurQV.addr.equals(myleaderInNewQV.addr));
                // we don't have a designated leader - need to go into leader
                // election
                reconfigFlagClear();
            }
            return roleChange || leaderChange;
        }
        return false;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#1" }, methods = { "keySet" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getId" })
    private void updateRemotePeerMXBeans(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Map<Long, QuorumServer> newMembers) {
        Set<Long> existingMembers = new HashSet<Long>(newMembers.keySet());
        existingMembers.retainAll(jmxRemotePeerBean.keySet());
        for (Long id : existingMembers) {
            RemotePeerBean rBean = jmxRemotePeerBean.get(id);
            rBean.setQuorumServer(newMembers.get(id));
        }
        Set<Long> joiningMembers = new HashSet<Long>(newMembers.keySet());
        joiningMembers.removeAll(jmxRemotePeerBean.keySet());
        // remove self as it is local bean
        joiningMembers.remove(getId());
        for (Long id : joiningMembers) {
            QuorumServer qs = newMembers.get(id);
            RemotePeerBean rBean = new RemotePeerBean(this, qs);
            try {
                MBeanRegistry.getInstance().register(rBean, jmxQuorumBean);
                jmxRemotePeerBean.put(qs.id, rBean);
            } catch (Exception e) {
                LOG.warn("Failed to register with JMX", e);
            }
        }
        Set<Long> leavingMembers = new HashSet<Long>(jmxRemotePeerBean.keySet());
        leavingMembers.removeAll(newMembers.keySet());
        for (Long id : leavingMembers) {
            RemotePeerBean rBean = jmxRemotePeerBean.remove(id);
            try {
                MBeanRegistry.getInstance().unregister(rBean);
            } catch (Exception e) {
                LOG.warn("Failed to unregister with JMX", e);
            }
        }
    }

    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ArrayList<QuorumServer> observerMasters = new ArrayList<>();

    private void updateObserverMasterList(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        if (observerMasterPort <= 0) {
            // observer masters not enabled
            return;
        }
        observerMasters.clear();
        StringBuilder sb = new StringBuilder();
        for (QuorumServer server : quorumVerifier.getVotingMembers().values()) {
            InetAddress address = server.addr.getReachableOrOne().getAddress();
            InetSocketAddress addr = new InetSocketAddress(address, observerMasterPort);
            observerMasters.add(new QuorumServer(server.id, addr));
            sb.append(addr).append(",");
        }
        LOG.info("Updated learner master list to be {}", sb.toString());
        Collections.shuffle(observerMasters);
        // Reset the internal index of the observerMaster when
        // the observerMaster List is refreshed
        nextObserverMaster = 0;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getLearnerType" })
    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean useObserverMasters(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return getLearnerType() == LearnerType.OBSERVER && observerMasters.size() > 0;
    }

    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int nextObserverMaster = 0;

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "isRunning" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.observerMasters" }, methods = { "get" })
    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumServer nextObserverMaster(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        if (nextObserverMaster >= observerMasters.size()) {
            nextObserverMaster = 0;
            // Add a reconnect delay only after the observer
            // has exhausted trying to connect to all the masters
            // from the observerMasterList
            if (isRunning()) {
                Observer.waitForReconnectDelay();
            }
        }
        return observerMasters.get(nextObserverMaster++);
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "useObserverMasters" })
    @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumServer findLearnerMaster(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumServer leader) {
        if (useObserverMasters()) {
            return nextObserverMaster();
        } else {
            // Add delay jitter to reduce the load on the leader
            if (isRunning()) {
                Observer.waitForReconnectDelay();
            }
            return leader;
        }
    }

    /**
     * Vet a given learner master's information.
     * Allows specification by server id, ip  only, or ip and port
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "useObserverMasters" })
    @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumServer validateLearnerMaster(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String desiredMaster) {
        if (useObserverMasters()) {
            Long sid;
            try {
                sid = Long.parseLong(desiredMaster);
            } catch (NumberFormatException e) {
                sid = null;
            }
            for (QuorumServer server : observerMasters) {
                if (sid == null) {
                    for (InetSocketAddress address : server.addr.getAllAddresses()) {
                        String serverAddr = address.getAddress().getHostAddress() + ':' + address.getPort();
                        if (serverAddr.startsWith(desiredMaster)) {
                            return server;
                        }
                    }
                } else {
                    if (sid.equals(server.id)) {
                        return server;
                    }
                }
            }
            if (sid == null) {
                LOG.info("could not find learner master address={}", desiredMaster);
            } else {
                LOG.warn("could not find learner master sid={}", sid);
            }
        } else {
            LOG.info("cannot validate request, observer masters not enabled");
        }
        return null;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#1" }, methods = { "getObservingMembers" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getId", "getLearnerType" })
    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean updateLearnerType(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({ "getAllMembers", "getVersion" }) QuorumVerifier newQV) {
        //check if I'm an observer in new config
        if (newQV.getObservingMembers().containsKey(getId())) {
            if (getLearnerType() != LearnerType.OBSERVER) {
                setLearnerType(LearnerType.OBSERVER);
                LOG.info("Becoming an observer");
                reconfigFlagSet();
                return true;
            } else {
                return false;
            }
        } else if (newQV.getVotingMembers().containsKey(getId())) {
            if (getLearnerType() != LearnerType.PARTICIPANT) {
                setLearnerType(LearnerType.PARTICIPANT);
                LOG.info("Becoming a voting participant");
                reconfigFlagSet();
                return true;
            } else {
                return false;
            }
        }
        // I'm not in the view
        if (getLearnerType() != LearnerType.PARTICIPANT) {
            setLearnerType(LearnerType.PARTICIPANT);
            LOG.info("Becoming a non-voting participant");
            reconfigFlagSet();
            return true;
        }
        return false;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getCurrentVote" })
    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean updateVote(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long designatedLeader,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long zxid) {
        Vote currentVote = getCurrentVote();
        if (currentVote != null && designatedLeader != currentVote.getId()) {
            setCurrentVote(new Vote(designatedLeader, zxid));
            reconfigFlagSet();
            LOG.warn("Suggested leader: {}", designatedLeader);
            return true;
        }
        return false;
    }

    /**
     * Updates leader election info to avoid inconsistencies when
     * a new server tries to join the ensemble.
     *
     * Here is the inconsistency scenario we try to solve by updating the peer
     * epoch after following leader:
     *
     * Let's say we have an ensemble with 3 servers z1, z2 and z3.
     *
     * 1. z1, z2 were following z3 with peerEpoch to be 0xb8, the new epoch is
     *    0xb9, aka current accepted epoch on disk.
     * 2. z2 get restarted, which will use 0xb9 as it's peer epoch when loading
     *    the current accept epoch from disk.
     * 3. z2 received notification from z1 and z3, which is following z3 with
     *    epoch 0xb8, so it started following z3 again with peer epoch 0xb8.
     * 4. before z2 successfully connected to z3, z3 get restarted with new
     *    epoch 0xb9.
     * 5. z2 will retry around a few round (default 5s) before giving up,
     *    meanwhile it will report z3 as leader.
     * 6. z1 restarted, and looking with peer epoch 0xb9.
     * 7. z1 voted z3, and z3 was elected as leader again with peer epoch 0xb9.
     * 8. z2 successfully connected to z3 before giving up, but with peer
     *    epoch 0xb8.
     * 9. z1 get restarted, looking for leader with peer epoch 0xba, but cannot
     *    join, because z2 is reporting peer epoch 0xb8, while z3 is reporting
     *    0xb9.
     *
     * By updating the election vote after actually following leader, we can
     * avoid this kind of stuck happened.
     *
     * Btw, the zxid and electionEpoch could be inconsistent because of the same
     * reason, it's better to update these as well after syncing with leader, but
     * that required protocol change which is non trivial. This problem is worked
     * around by skipping comparing the zxid and electionEpoch when counting for
     * votes for out of election servers during looking for leader.
     *
     * See https://issues.apache.org/jira/browse/ZOOKEEPER-1732
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getCurrentVote" })
    protected void updateElectionVote(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long newEpoch) {
        Vote currentVote = getCurrentVote();
        if (currentVote != null) {
            setCurrentVote(new Vote(currentVote.getId(), currentVote.getZxid(), currentVote.getElectionEpoch(), newEpoch, currentVote.getState()));
        }
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getId", "setName" })
    private void updateThreadName(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        String plain = cnxnFactory != null ? cnxnFactory.getLocalAddress() != null ? formatInetAddr(cnxnFactory.getLocalAddress()) : "disabled" : "disabled";
        String secure = secureCnxnFactory != null ? formatInetAddr(secureCnxnFactory.getLocalAddress()) : "disabled";
        setName(String.format("QuorumPeer[myid=%d](plain=%s)(secure=%s)", getId(), plain, secure));
    }

    /**
     * Sets the time taken for leader election in milliseconds.
     *
     * @param electionTimeTaken time taken for leader election
     */
    void setElectionTimeTaken(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long electionTimeTaken) {
        this.electionTimeTaken = electionTimeTaken;
    }

    /**
     * @return the time taken for leader election in milliseconds.
     */
    @org.checkerframework.dataflow.qual.Pure
     @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long getElectionTimeTaken(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return electionTimeTaken;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "org.apache.zookeeper.server.quorum.QuorumPeer.LOG" }, methods = { "info" })
    void setQuorumServerSaslRequired(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "isQuorumSaslAuthEnabled" }) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean serverSaslRequired) {
        quorumServerSaslAuthRequired = serverSaslRequired;
        LOG.info("{} set to {}", QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, serverSaslRequired);
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "org.apache.zookeeper.server.quorum.QuorumPeer.LOG" }, methods = { "info" })
    void setQuorumLearnerSaslRequired(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "setQuorumServerSaslRequired" }) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean learnerSaslRequired) {
        quorumLearnerSaslAuthRequired = learnerSaslRequired;
        LOG.info("{} set to {}", QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, learnerSaslRequired);
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "org.apache.zookeeper.server.quorum.QuorumPeer.LOG" }, methods = { "info" })
    void setQuorumSaslEnabled(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "setMultiAddressReachabilityCheckTimeoutMs" }) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean enableAuth) {
        quorumSaslEnableAuth = enableAuth;
        if (!quorumSaslEnableAuth) {
            LOG.info("QuorumPeer communication is not secured! (SASL auth disabled)");
        } else {
            LOG.info("{} set to {}", QuorumAuth.QUORUM_SASL_AUTH_ENABLED, enableAuth);
        }
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "org.apache.zookeeper.server.quorum.QuorumPeer.LOG" }, methods = { "info" })
    void setQuorumServicePrincipal(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "setQuorumLearnerSaslRequired" }) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String servicePrincipal) {
        quorumServicePrincipal = servicePrincipal;
        LOG.info("{} set to {}", QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL, quorumServicePrincipal);
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "org.apache.zookeeper.server.quorum.QuorumPeer.LOG" }, methods = { "info" })
    void setQuorumLearnerLoginContext(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "setQuorumServerLoginContext" }) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String learnerContext) {
        quorumLearnerLoginContext = learnerContext;
        LOG.info("{} set to {}", QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT, quorumLearnerLoginContext);
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "org.apache.zookeeper.server.quorum.QuorumPeer.LOG" }, methods = { "info" })
    void setQuorumServerLoginContext(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "setQuorumServicePrincipal" }) QuorumPeer this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String serverContext) {
        quorumServerLoginContext = serverContext;
        LOG.info("{} set to {}", QuorumAuth.QUORUM_SERVER_SASL_LOGIN_CONTEXT, quorumServerLoginContext);
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "org.apache.zookeeper.server.quorum.QuorumPeer.LOG" }, methods = { "info" })
    void setQuorumCnxnThreadsSize(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int qCnxnThreadsSize) {
        if (qCnxnThreadsSize > QUORUM_CNXN_THREADS_SIZE_DEFAULT_VALUE) {
            quorumCnxnThreadsSize = qCnxnThreadsSize;
        }
        LOG.info("quorum.cnxn.threads.size set to {}", quorumCnxnThreadsSize);
    }

    @org.checkerframework.dataflow.qual.Pure
     @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isQuorumSaslAuthEnabled(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return quorumSaslEnableAuth;
    }

    @org.checkerframework.dataflow.qual.Pure
    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isQuorumServerSaslAuthRequired(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return quorumServerSaslAuthRequired;
    }

    @org.checkerframework.dataflow.qual.Pure
    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isQuorumLearnerSaslAuthRequired(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return quorumLearnerSaslAuthRequired;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "org.apache.zookeeper.server.quorum.QuorumPeer.LOG" }, methods = { "info" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getId", "getQuorumListenOnAllIPs", "getView", "isQuorumSaslAuthEnabled" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumCnxManager createCnxnManager(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        int timeout = quorumCnxnTimeoutMs > 0 ? quorumCnxnTimeoutMs : this.tickTime * this.syncLimit;
        LOG.info("Using {}ms as the quorum cnxn socket timeout", timeout);
        return new QuorumCnxManager(this, this.getId(), this.getView(), this.authServer, this.authLearner, timeout, this.getQuorumListenOnAllIPs(), this.quorumCnxnThreadsSize, this.isQuorumSaslAuthEnabled());
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getCurrentVote" })
     @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isLeader(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long id) {
        Vote vote = getCurrentVote();
        return vote != null && id == vote.getId();
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isReconfigEnabled(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) QuorumPeer this) {
        return reconfigEnabled;
    }

    /**
     * This is a metric that depends on the status of the peer.
     */
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Integer getSynced_observers_metric() {
        if (leader != null) {
            return leader.getObservingLearners().size();
        } else if (follower != null) {
            return follower.getSyncedObserverSize();
        } else {
            return null;
        }
    }
}
