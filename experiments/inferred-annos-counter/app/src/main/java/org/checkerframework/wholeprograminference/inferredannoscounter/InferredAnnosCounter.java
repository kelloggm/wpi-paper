/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package inferred.annos.counter;

import java.io.File;
import java.io.*;
import java.io.IOException;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.List;
import java.util.*;

import com.github.difflib.DiffUtils;
import com.github.difflib.patch.Patch;
import com.github.difflib.patch.AbstractDelta;


public class App {
    public static void main(String[] args) {
        if (args.length <= 1) {
            throw new RuntimeException("Provide at least one .java file and one or more" +
                    ".ajava files.");
        }
        List<String> originalFile = new ArrayList<String>();
        List<String> important_anno= new ArrayList<String>();
        int count=0;
        //specific annotations and the number of computer-written codes missing them
        Map<String, Integer> anno_locate = new HashMap<String, Integer>();
        // the name of the types of annotation and their numbers in the human-written code
        Map<String, Integer> anno_count = new HashMap<String, Integer>();
        /* the name of the types of annotations and their "correct" numbers (meaning the number of annotations of that
        type not missed by computer-written codes) */
        Map<String, Integer> anno_countdiff = new HashMap<String, Integer>();
        try {
            File file = new File(args[0]);
            // Initialize the array of words
            String[] words = null;  
            // Create the File Reader object
            FileReader fr = new FileReader(file);
            // Create the BufferedReader object
            BufferedReader br = new BufferedReader(fr);  
            String str;
            // lines counter
            int pos=-1;
            while((str = br.readLine()) != null)  
            {
                pos++;
               originalFile.add(str);
               // Split the word using space
               words = str.split(" ");  
               for (int i=0; i< words.length; i++)
               {
                   String word=words[i];
                   //the next two ifs are to check if "word" is a valid annotation
                  if (word.length()!=0)
                  {
                      if (word.contains("@") && !words[i-1].equals("*") ) {
                          //this is for cases such as ArrayList<@Anno(abcd)...., we only want the "@Anno(abcd)" part.
                          int index1=word.indexOf("@");
                          //this is for cases such as @Option(abc), we only want the "@Option" part.
                          if (word.contains("(")) {
                              int index=word.indexOf("(");
                              word=word.substring(index1,index);
                          }
                          else
                          {
                              word=word.substring(index1, word.length());
                          }
                      //get the position of that annotation in the code
                              String posi = String.valueOf(pos);
                              if (anno_count.containsKey(word))
                              {
                                  int x=anno_count.get(word);
                                  anno_count.put(word, x+1);
                              }
                              else
                              {
                                  anno_count.put(word, new Integer(1));
                              }
                              anno_countdiff.put(word, new Integer(0));
                              //we want the keys in the map anno_locates has this following format: type_position
                              String x = word + "_" + posi;
                              anno_locate.put(x, new Integer(0));
                      }
                  }
               }
            }
            fr.close(); 
        } 
        
        catch (IOException e) {
            throw new RuntimeException("Could not read file: " + args[0] + ". Check that it exists?");
        }
        List<Patch<String>> diffs = new ArrayList<>(args.length - 1);
        for (int i = 1; i < args.length; ++i) {
            try {
                List<String> newFile= new ArrayList<String>();
                File file = new File(args[i]);
                // Initialize the array of words
                String[] words = null;
                // Create the File Reader object
                FileReader fr = new FileReader(file);
                // Create the BufferedReader object
                BufferedReader br = new BufferedReader(fr);
                String str;
                // Word to search
                String search = "@org.checkerframework";
                while((str = br.readLine()) != null)
                {
                    newFile.add(str);
                    // Split the word using space
                    words = str.split(" ");
                    for (int in=0; in< words.length; in++)
                    {
                        String word=words[in];
                        //the next three ifs are to check if "word" is a valid annotation
                        if (word.length()!=0)
                        {
                            /* For cases such as this:
                                          * @ABC
                            we will skip it since it belongs to a comment
                            */
                            if (in>0)
                            {
                                if (word.contains(search) && !words[in-1].equals("*"))
                                {
                                    /* for an annotation such as "@org.checkerframework...Nullable", we will extract the
                                    "@Nullable" part */
                                    String[] breakk=word.split("[.]");
                                    int size= breakk.length;
                                    String notic=breakk[size-1];
                                    int z=0;
                                    for (int county= 0; county < notic.length(); county++) {
                                        if (!Character.isLetter(notic.charAt(county))) {
                                            break;
                                        }
                                        z++;
                                    }
                                    notic=notic.substring(0, z);
                                    notic="@"+notic;
                                    important_anno.add(notic);
                                }
                            }
                            /* if "in" is not larger than 0, it means that there must be no "*" before this annotation,
                            so it will not belong to a comment */
                            else
                            {
                                if (word.contains(search))
                                {
                                    String[] breakk=word.split("[.]");
                                    int size= breakk.length;
                                    String notic=breakk[size-1];
                                    int z=0;
                                    for (int county= 0; county < notic.length(); county++) {
                                        if (!Character.isLetter(notic.charAt(county))) {
                                            break;
                                        }
                                        z++;
                                    }
                                    notic=notic.substring(0, z);
                                    notic="@"+notic;
                                    important_anno.add(notic);
                                }
                            }

                        }
                    }
                }
                fr.close();
                diffs.add(DiffUtils.diff(originalFile, newFile));
            } catch (IOException e) {
                throw new RuntimeException("Could not read file: " + args[i] + ". Check that it exists?");
            }
        }
        for (int i=0; i<args.length -1; i++)
        {
            Patch<String> patch= diffs.get(i);
            boolean notcomment=false;
            for (AbstractDelta<String> delta : patch.getDeltas()) {
                //get the delta in string format
               String x= delta.toString();
               notcomment=true;
                //we change the delta output to a string, then break that string into different parts
               List<String> myList = new ArrayList<String>(Arrays.asList(x.split(" ")));
               //just take the delta with annotations into consideration
               if (x.contains("@"))
               {
                   //get the position of that annotation in the delta, which is something like "5," or "6,".
               String pos=myList.get(2);
               //take the "," out
               String newpos = pos.substring(0, pos.length() - 1);
               String result="";
               for (String element: myList)
               {
                   //we dont take differences in the comment section into consideration
                   if (element.equals("//"))
                   {
                       notcomment=false;
                   }
                   if (notcomment && element.contains("@"))
                   {
                       /*
                       The Diff algorithm will state that "@org.checkerframework.dataflow.qual.Pure" is different from
                       "@Pure". We will let it do that and update the data of anno_locates based on that observation,
                       which is to add the value of the @Pure key by 1. But we will add a piece of codes that see
                       "@org.checkerframework.dataflow.qual.Pure" as "@Pure" and look it up on anno_locates, then
                       decrease the number of that @Pure key by 1.
                       */
                       if (element.contains("@org.checkerframework"))
                       {
                           String word=element;
                           String[] breakk=word.split("[.]");
                           int sizey= breakk.length;
                           String notic=breakk[sizey-1];
                           int z=0;
                           for (int county= 0; county < notic.length(); county++) {
                               if (!Character.isLetter(notic.charAt(county))) {
                                   break;
                               }
                               z++;
                           }
                           notic=notic.substring(0, z);
                           notic="@"+notic;
                           notic=notic+"_"+newpos;
                           if (anno_locate.containsKey(notic))
                           {
                               int value=anno_locate.get(notic);
                               value=value-1;
                               anno_locate.put(notic,value);
                           }
                       }
                       else
                       {
                           int index1=element.indexOf("@");
                           element=element.substring(index1,element.length());
                           int count2=0;
                           int size=element.length();
                           for (int county=1; county<size; county++)
                           {
                               if (!Character.isLetter(element.charAt(county))) {
                                   count2=county;
                                   break;
                               }
                               count2=county;
                           }
                           element=element.substring(0, count2);
                           //to match the one in anno_locate
                           result=element+"_"+newpos;
                           //update the data of anno_locate
                           if (anno_locate.containsKey(result))
                           {
                               int value=anno_locate.get(result);
                               value=value+1;
                               anno_locate.put(result,value);
                           }
                       }
                   }
               }
               }
         }
        }
        //update the data of anno_countdiff
        for (Map.Entry<String, Integer> me :
                anno_locate.entrySet()) {
            String k=me.getKey();
            /*if the number of computer-written code missing that element is less than the total number of codes written
            by computer, the at least one of those computer-written code must have gotten the annotation correct*/
            if (me.getValue()<args.length-1)
            {
                //for example, if we have @Option_345, we will only need "@Option" since we want the general type here
                int index=k.indexOf("_");
                k=k.substring(0,index);
                int value=anno_countdiff.get(k);
                value=value+1;
                anno_countdiff.put(k, value);
            }
        }

        System.out.println();
        for (Map.Entry<String, Integer> e : anno_count.entrySet())
        {
            int x=e.getValue();
            String value=e.getKey();
            int y=anno_countdiff.get(value);
            if (important_anno.contains(value))
            {
                System.out.println(value + " got " + y + "/" + x );
            }
        }
        System.out.println();
    }
}
