\section{Practical Considerations}
\label{sec:difficulties}

The algorithm and type rules in \cref{sec:algorithm} define our
basic approach. This section describes some challenges
in building a system that applies
to every pluggable typechecker and is effective at inferring
type qualifiers for real programs.


\subsection{Analysis Termination: Infinite Descending Chains and Recursive Calls}
\label{sec:infinite-descending-chains}

The usual lattice definition in an abstract interpretation
(or equivalently~\cite{Cousot1997}, a type system with flow-sensitive type
refinement) forbids
infinite ascending chains but permits infinite descending chains.
A typechecker whose type system includes an infinite descending chain
is guaranteed to terminate when typechecking a program (that is, the inner
loop of the iterated local type inference algorithm), but the
algorithm can induce downward refinement in the outer loop
(\ie during \cref{alg:wpi-fixpoint}).

For example, consider a type system for integer intervals
whose type qualifiers are of the form \<range(\|from|, \|to|)>.
The type \<range(1, 10) int> means ``an integer between
1 and 10, inclusive''.
The subtyping relationship is straightforward: \<range(a, z)>
is a supertype of \<range(b, y)> if and only if $\<a> \le \<b> \wedge \<z>
\ge \<y>$.\todo{That relationship looks exactly backward to me.}
Then consider running our inference algorithm on the program in \cref{fig:descend}
using this type system.

\begin{figure}
\begin{verbatim}
int recurse(int x) {
  return recurse(x + 1);
}

recurse(0);
\end{verbatim}
\caption{Simple example that would trigger an infinite loop in a naive
  implementation of our analysis.}\todo{Talk about infinite downward
  chains, probably.}
\label{fig:descend}
\end{figure}

When typechecking this program, the pluggable typechecker will
treat both the input and output of \<recurse> as the top type
(\ie any integer). However, the \textsc{INVOKE} rule in \cref{fig:type-rules}
results in the fixpoint algorithm getting stuck in an arbitrarily-long
loop attempting to infer a type for the parameter \<x>: the call to \<recurse(0)>
results in a qualified type of \<range(0, 0)> for \<x>. Constant
propagation then leads to the type \<range(0, 1)> in the next iteration
of the outer (fixpoint) loop, then to \<range(0, 2)>\todo{This is a
  \emph{supertype} of \<range(0, 1)>: it admits more values.}, \ldots, which
is undesirable.

In practice, we found that a simple modification to the invocation rule that
prevents type qualifier inference from recursive method calls is sufficient
to prevent this problem in practice.
%
Though mutual recursion is a problem in
theory, in our benchmarks we did not encounter any code that triggered such
an infinite loop in the analysis.
%
Future work should address this problem in
a more principled way, such as by introducing narrowing operators
(similar to widening operators in an abstract interpretation, which
permits an abstract interpretation to handle lattices with infinite
ascending chains~\cite{CousotC77:AI}~\todo{Is this the right citation for widening?}).
A downside to using narrowing operators is that defining them would
be a per-typechecker task, but fortunately the type hierarchies of many
pluggable typecheckers do not contain infinite descending chains at all.

\subsection{Pre- and Post-conditions}
\label{sec:pre-post-conditions}

Discuss some of the troubles that Mike encountered when
he implemented pre- and post-condition support in WPI\@. Frame
this as a theoretical problem. \todo{Mike should write this section.}


\subsection{Type-system-specific inference}
\label{sec:type-system-specific}


\subsection{Storing intermediate results}
\label{sec:output}

\todo{Restructure}

\Cref{alg:wpi-fixpoint} does not specify how to store the intermediate
sets of candidate type qualifiers (\ie $A^{\prime}$). How these intermediate
sets of type qualifiers are stored presents a subtle challenge: we need
to treat type qualifers supplied by the programmer differently than
type qualifiers that were produced during earlier rounds of inference:
the latter may be further refined, but the former must not be.

We considered three approaches to store intermediate candidate qualifier sets:
\begin{enumerate}
\item insert the inferred type qualifiers directly into the program.
\item store the inferred type qualifiers in a side file, as if they were
  programmer-provided specifications for unannotated libraries.
\item store the inferred type qualifiers in a special, inference-specific
  side file.
\end{enumerate}

Only strategy 3 is effective in practice.

The problem with strategy 1 is that it becomes impossible to distinguish
between qualifiers written by the programmer themselves and qualifiers
inferred in previous fixpoint rounds. Because the programmer might write
qualifiers themselves to prevent the inference system from making overly-precise
refinements (which would result in type errors in \eg other modules not currently
under compilation), the analysis should not further refine any qualifiers
provided by the programmer.

The problem with strategy 2 is that
the requirements for ``library qualifier'' side files and inferred side files
are quite different. Consider the case where a library qualifier side file and
a source file exist for the same class. In this case, the sensible default is
to \emph{ignore} the library qualifier file, because the source code is actually
the ground truth. This problem is compounded by typechecker writers distributing
library qualifier files for common libraries. We tried forcing
all library qualifier files to be placed into source code, but this made inference
not work properly on common libraries for which checker-distributed library qualifier files
existed.

In strategy 3, the side files share the same syntax as library side files, but
have different semantics: they are treated totally separately. Library side files
are never modified during the inference process, but inference side files change
on each iteration of the outer loop in \cref{alg:wpi-fixpoint}.

\subsection{Inference of Purity}
\label{sec:purity-inference}

\todo{Write a section about how important it is to infer purity annotations,
  and how our approach does that. Mike should probably write this section
  (Martin definitely did not implement the purity inference mechanism; he is not
  sure who did.)}

% LocalWords:  typechecker typecheckers typechecking ajava
